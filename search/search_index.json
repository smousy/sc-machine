{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation","text":"<ul> <li>Building<ul> <li>Linux</li> <li>macOS</li> <li>CMake flags</li> </ul> </li> <li> <p>Common</p> <ul> <li>Config - description of a configuration file</li> <li>Sc-element types - detailed description of supported element types</li> <li>SCs-language - documentation on SCs-language with examples</li> </ul> </li> <li> <p>C++ API</p> <ul> <li>Common - documentation on common principles of C++ API</li> <li>Knowledge processing machine - documentation on Knowledge Processing Machine API</li> <li>Meta programming - documentation of meta programming language</li> <li>Templates - documentation of template usage</li> <li>File storage - documentation of file storage</li> </ul> </li> <li> <p>Tools</p> <ul> <li>Knowledge Base builder</li> </ul> </li> <li> <p>Development</p> <ul> <li>Git workflow</li> <li>Codestyle</li> </ul> </li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#breaking-changes","title":"Breaking changes","text":"<ul> <li>Now we use C++17 instead of C++14</li> <li>We support compatibility with old memory binaries</li> </ul>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Ability do not search for sc-links by substrings globally, passing config param <code>search_by_substring</code></li> <li>Ability do not search for sc-links by strings locally, passing param in SetLinkContent <code>is_searchable</code></li> <li>Generalize all scripts for applied projects</li> <li>Script <code>build_sc_machine.sh</code> with arguments <code>-f</code> <code>-t</code> and <code>-r</code> instead of <code>make_all.sh</code></li> <li>View kb fragment in scn if it is keyword</li> <li>Tests for repo-path parser and sources collector in <code>sc-builder</code></li> <li>Support for deprecated memory binaries build in 0.7.0 version</li> <li>Synchronize processes that works with file memory and sc-dictionary</li> <li>Get replacements in template result by variable addresses</li> <li>Divide strings file into more small files with fixed size by requested configs <code>max_strings_channels</code> and <code>max_strings_channel_size</code></li> <li>Configuration of docker-compose.yml using .env file</li> <li>Script <code>run_tests.sh</code></li> <li>Full tests for file memory API</li> <li>Intersect/unite search sc-links by strings and substrings in file memory</li> <li>Search strings and sc-link hashes by terms in file memory</li> <li>File memory on file system, save strings in file system disks</li> <li>Configure events and agents threads in sc-memory, passing config param <code>max_events_and_agents_threads</code></li> <li>Loop-ranged API method for sc-template search (78)</li> <li>Full tests for sc-template API</li> <li>Sc-template cycle preventing search</li> <li>Sc-template equal triples search</li> <li>Sc-template search API to get and use constructions step by step</li> <li>Sc-template search API to custom filter constructions with step by step search</li> <li>Sc-template search API with request commands (continue search, stop search and error during search)</li> <li>Cover all sc-template search and gen API with tests</li> <li>Order triples by type and dependencies with other triples</li> <li>Count input/output edges in elements during edges adding</li> <li>Order triples by input/output edges count for triple items</li> <li>Determined sc-template depth-first search</li> <li>Sc-template safe API without exceptions handling</li> <li>Extend create elements by SCs in <code>sc-server</code> with outputStructure field</li> <li>Write docs for system identifier set/get/find/resolve sc-memory API</li> <li>Extend set/get/find/resolve sc-memory API with out system identifier fiver parameters</li> <li>Insert sc-keynodes in global knowledge base during sc-memory initiation</li> <li>Save sc-memory by period in sc-server, passing config param <code>save_period</code> in seconds</li> <li>Dump statistics by period in sc-server, passing config param <code>update_period</code> in seconds</li> <li>Agent for erasing sc-elements not belonging to the global structure <code>init_memory_generated_structure</code></li> <li>Transfer init memory generated structure to modules initialization, passing config params <code>init_memory_generated_upload</code> and <code>init_memory_generated_structure</code></li> <li>Possibility to skip keys defined in .ini config file in ScConfig</li> <li>Pre-commit code style checks for C++ and Python</li> <li>Add reversed edges according to standart</li> <li>Sc-links classes <code>![]!</code> in SCs</li> <li>Insert sc-keynodes and their system identifiers in global knowledge base during sc-memory initiation</li> <li>Extend create elements by SCs in <code>sc-server</code> with outputStructure field</li> <li>Write docs for system identifier set/get/find/resolve sc-memory API</li> <li>Extend set/get/find/resolve sc-memory API with outer system identifier fiver parameters</li> <li>CI for documentation build</li> <li>Add output structure builder feature to config</li> <li>Add validation of system identifier</li> <li>Append generated elements by <code>SCs-helper</code> into requested output structure</li> <li>Oriented sets representation () in SCs <li>Build docs in SCn format separately from <code>ostis-web-platform</code></li>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Refactor sc-server logs</li> <li>Decrease wait time for sc-element referencing in iterators</li> <li>Call gwf-translator in sc-builder</li> <li>Move repo path parser from Python to C++ in sc-builder</li> <li>Unite ScTemplateGenResult and ScTemplateSearchResultItem into ScTemplateResultItem</li> <li>Remove list to array translations in C API for file memory</li> <li>Upload text and binary files in realtime by get API</li> <li>Remove string lengths recount in file memory</li> <li>Optimize int to string translation in file memory</li> <li>Use iterators instead of sc-template in <code>getNextFromSet</code> util</li> <li>Generalized <code>docker_entrypoint.sh</code>, this script can be used by external projects now</li> <li>Now in tests all agents works in single thread</li> <li>Replace asserts in sc-template search and gen API by exceptions throwing</li> <li><code>ScsLoader::loadScsFile</code> return bool instead void</li> <li>Update garbage deletion agent logic, add check if element belongs to init memory structure</li> <li>Make scsi pre-processor migrations script</li> <li>Move to C++17</li> <li>Remove 1 minute assert in <code>ScWait</code></li> <li>Add language parameter for sc2scs-json-translator to get elements identifiers</li> <li>Append to sc2scs-json elements main/system identifiers</li> <li>Replace row strings by nlohmann-json in sc2scs-json-translator</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Change memory statistics fields types from sc_uint32 to sc_uint64</li> <li>Return empty sc_addr if not found by identifier in <code>sc-helper</code></li> <li>Build kb script doesn't ignore whitespace (239)</li> <li>Docker entrypoint throws integer expression expected (267)</li> <li>KB directory coping to prepare gwf and scsi sources </li> <li>Tests for template build and gen with params</li> <li>Aliases checking in build by scs</li> <li>Not use system identifiers of vars in sc-template-build</li> <li>Sc-template search by empty template (65)</li> <li>Segfaults in test sc-client</li> <li>Creating sc-keynodes without defining type. Now they will be created with const node type.</li> <li>Converting to string params from configs</li> <li>Fix hashes size in fs-storage (45)</li> <li>GetLinkContent skip whitespaces in strings</li> <li>No inserting system identifiers of keynodes to output structure (223)</li> <li><code>SCs-helper</code> doesn't return generated identifier links (207)</li> <li>No json string message parsing in <code>sc-server</code> (WebSocket request dumps sc-machine) (190)</li> <li>SCs-file dumps kb-builder by WebSocket (189)</li> <li><code>SCs-parser</code> create structure twice</li> <li><code>SCs-parser</code> doesn't unite all generated elements into structure (205)</li> <li>Link deletion (193)</li> <li>Add curl to installation script</li> <li>Fix memory clear parameter reading from .ini config file</li> <li>Merging identifiers in sc-dictionary (192)</li> <li>Dependence order in var template search triples (186)</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Windows files and cmake dependencies</li> <li>Prepare kb step and <code>prepare_kb.py</code></li> <li>Rocksdb file memory</li> <li>Garbage deletion agent</li> </ul>"},{"location":"changelog/#070-rebirth-12102022","title":"[0.7.0-Rebirth] - 12.10.2022","text":""},{"location":"changelog/#breaking-changes_1","title":"Breaking changes","text":"<ul> <li>Binaries are built in the <code>bin</code> folder located near the CMake build tree. This will affect any project using sc-machine as a CMake subproject.</li> <li>Add <code>;</code> after <code>SC_LOG_INFO</code>, <code>SC_LOG_DEBUG</code>, <code>SC_LOG_WARNING</code> and <code>SC_LOG_ERROR</code> calls in projects that use sc-machine.</li> <li>Add <code>;</code> after <code>SC_ASSERT</code> calls in projects that use sc-machine.</li> <li>Remind that all binary content are stored in sc-fs-storage as base64 string.</li> <li>sctp-server was removed, move to sc-server usage.</li> <li>SC-machine doesn't support ubuntu versions lower than 20.04.</li> </ul>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Implement sc-link content removing from sc-storage</li> <li>Add command to find links contents by content substring into sc-server</li> <li>Implement find links contents by content substring into sc-server</li> <li>CI for docker build and run</li> <li>CI for ubuntu-22.04 and latest macOS</li> <li>Add ScExec class to execute system commands</li> <li>Test for utils for work with actions and their results</li> <li>Handle and save sc-server subcommands errors</li> <li>Add sc-server healthcheck</li> <li>Add tests for sc-search agents in sc-kpm</li> <li>Write sc-machine idea into readme</li> <li>Add create elements by scs-helper through sc-server</li> <li>Add CI workflow for sanitizers</li> <li>Add find links by substring in sc-server</li> <li>Initial development container support</li> <li>You can now run sc-machine in Docker</li> <li>Unite configuration for sc-server and sc-builder</li> <li>Write docs in scn-latex for sc-server</li> <li>Implement sc-memory configurator</li> <li>Implement sc-options for sc-server and sc-builder usages</li> <li>Implement sc-server on C++</li> <li>Add string API for set and get link content</li> <li>Add opportunity to search sc-links in <code>sc-dictionary</code> by content substr</li> <li>Excludes for files and folders in repo.path</li> <li>Automatic usage of ccache to speed up builds</li> <li>Add CI for <code>rocksdb</code> and <code>sc-dictionary</code></li> <li>Implement <code>sc-dictionary</code>. Add opportunity to switch <code>rocksdb</code> and <code>sc-dictionary</code></li> <li>Wrap and separate allocating, assertion, notification and atomic lock free procedures</li> <li>Add tests module for sc-agents-utils</li> <li>Add opportunity to configure sc-machine version from CMakeLists.txt</li> <li>Add scripts to build kb, run sctp-server and run sc-server</li> <li>New flag options for build_kb</li> <li>Add default python modules paths to python initialization</li> <li>United config file</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Fix sc-server json casts to strings</li> <li>Check sc-server run in tests</li> <li>Flag --tests for sc-server to run and quick stop it</li> <li>Fix glib casts on ubuntu-20.04 and macOS</li> <li>Store binary content as base64 string</li> <li>Update action utils to use the new logic for waiting for action results</li> <li>Fix logic of waiting for action results</li> <li>Entrypoint of Docker image is now easier to work with</li> <li>Update commit badges</li> <li>Up codecov target from 40% to 75%</li> <li>Up codecov level from 62% to 78%</li> <li>Separate ci workflow: check pr-commit, codestyle and tests</li> <li>Revamped README.md</li> <li>Unify sc-builder and sc-server config and params usage</li> <li>Change sc-machine config file structure</li> <li>Fix gwf2scs-translator. Add opportunity to parse russian identifiers</li> <li>Simplify main CMakeLists.txt</li> <li>Add tools macros for main CMakeLists.txt</li> <li>Separate dependencies specifying from main CMakeLists.txt</li> <li>Correct typos</li> <li>Fix warnings in sc-memory modules</li> <li>Fix scs-grammar. Add opportunity to specificate a structure into this structure itself</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Remove find by substring logic from sc-dictionary</li> <li>Remove legacy gwf-translator for 0.3.0 gwf sources from sc-builder</li> <li>Remove legacy glib-based tests</li> <li>Remove boost usage for options parsing in sc-server and sc-builder</li> <li>Unlink boost-python-lib from sc-machine</li> <li>Remove mkdocs for sc-server</li> <li>Remove sc-python-interpreter support</li> <li>Remove sc-python-module support</li> <li>Remove python sc-server</li> <li>Move logic rule utils and keynodes to ostis-inference</li> <li>Remove sctp-server</li> <li>Remove scp-interpreter</li> </ul>"},{"location":"changelog/#061-27042022","title":"0.6.1 - 27.04.2022","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Search by template with params in C++ API</li> <li>Sanitizers</li> <li>Benchmarks</li> <li>Clang code formatting</li> <li>Common utils for C++ API</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Migrate test system to <code>gtest</code></li> <li>Update macOS install_deps script</li> <li>Multithreaded build process used by default</li> <li>Move changelog to Keep a Changelog format</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li>Moved React web interface in a separate new repository.</li> <li>Remove optional search triples support</li> </ul>"},{"location":"changelog/#v060","title":"v0.6.0","text":"<ul> <li> <p>Build system:</p> </li> <li> <p>Add support of OSX platform</p> </li> <li>Fix compilation with <code>clang</code></li> <li>Disable <code>SCP</code> and <code>SCTP</code> compilation by default</li> <li>Support of C++14</li> <li>Use Ubuntu 18.04 on Travis CI</li> <li> <p>Upgrade <code>libclang</code> to version 7</p> </li> <li> <p>Tools:</p> </li> <li> <p>Support custom extensions loading in <code>sc-builder</code></p> </li> <li>Add <code>sc-server</code> application to run claen <code>sc-memory</code> with extensions</li> <li>Refactored code generation tool</li> <li> <p>Refactored knowledge base tool</p> </li> <li> <p>Core:</p> </li> <li> <p>Support list of enabled extensions</p> </li> <li>Support all possible combinations of <code>sc_iterator3</code></li> <li>Support variable <code>sc-links</code></li> <li>Fix bug with repo directory write attributes</li> <li>Fix issue with extension loading on windows</li> <li>Fix issue with empty content of <code>sc-link</code></li> <li> <p>Refactored file memory to use rocksdb</p> </li> <li> <p>C++:</p> </li> <li> <p>Implement optional search triples support</p> </li> <li>Fix random crash of unittest</li> <li>Improve test system</li> <li>Replace <code>antlr3</code> with <code>antlr4</code> for <code>SCs-text</code> parsing</li> <li>Support of <code>SCs-text</code> aliases</li> <li>Support of 5 and 6 levels of <code>SCs-text</code></li> <li>Refactored test system</li> <li>Refactored API of <code>ScLink</code> and <code>ScStream</code></li> <li> <p>Add generation of structure from <code>SCs-text</code></p> </li> <li> <p>Python:</p> </li> <li> <p>Refactored test system</p> </li> <li>Support SCs-templates in WebSocket protocol</li> <li>Add support of template building from <code>SCs-code</code> string</li> <li>Add <code>Aliases</code> method to <code>ScTemplateSearchResult</code> and <code>ScTemplateGenResult</code></li> <li>Fix issue with float/double values support</li> <li>Add support of logs inside python modules</li> <li> <p>Support <code>ActionAgent</code> states</p> </li> <li> <p>KPM:</p> </li> <li> <p>web:</p> <ul> <li>Implement <code>http</code> module to access memory via Web interface</li> <li>Implement web browser interface to access <code>sc-memory</code></li> </ul> </li> <li> <p>Remove of <code>sc-merge</code> module</p> </li> <li> <p>Documentation:</p> </li> <li>Improve <code>SCs-code</code> documentation. Add levels <code>5</code> and <code>6</code></li> </ul>"},{"location":"changelog/#v050","title":"v0.5.0","text":"<ul> <li> <p>Build system:</p> </li> <li> <p>Add Visual Studio 2017 support</p> </li> <li> <p>Core:</p> </li> <li> <p>Fix bug with repository save (case when it output directory doesn't exist)</p> </li> <li> <p>C++:</p> </li> <li> <p>Fix bugs in python GIL work</p> </li> <li>Fix python threading</li> <li>Fix problem with twicely pass of edge in template search</li> <li>Fix problem with stack overflow on large template search</li> <li>Fix some python wrapping functions</li> <li>Improve <code>ScType</code> class</li> <li>Add types support in SCs-parser</li> <li>Add keynode cache</li> <li>Add <code>ScTemplate</code> build from SCs-text</li> <li> <p>Add support of pending events. Now events emit after whole template generated</p> </li> <li> <p>Python:</p> </li> <li> <p>Add <code>ScAgent</code> class</p> </li> <li>Improve custom main cycle in <code>ScModule</code></li> <li>Improve python testing</li> <li> <p>Implement <code>ScHelper</code> class</p> </li> <li> <p>Tools:</p> </li> <li> <p>Fix error handling in sc-builder</p> </li> <li> <p>Fix <code>show-filenames</code> parameter processing in sc-builder</p> </li> <li> <p>Documentation</p> </li> <li>Update documentation theme</li> <li>Improve python library documentation</li> <li>Support <code>SCs-syntax</code> highlight in documentation</li> </ul>"},{"location":"changelog/#v041","title":"v0.4.1","text":"<ul> <li>Add <code>ScSet</code> and <code>ScRelationSet</code> in python common library</li> <li>Add <code>ScPythonService</code> into C++ (allow to implement threaded python services)</li> <li>Add <code>GetType</code> and <code>AsBinary</code> functions into Python for a link content</li> <li>Add colors to python output</li> <li>Add signal handler to handle <code>Ctrl + C</code></li> <li>Fix bug with python modules search path initialization</li> <li>Fix bug with python threading</li> <li>Fix bug with builder run</li> <li>Fix bug with <code>ScLock</code></li> <li>Fix bug with Python interpreter shutdown</li> <li>Fix bug with <code>int8_t</code> type support in python bindings</li> <li>Fix bug with template generation, when pass parameter to triple with type that has no constancy flag</li> <li>Fix errors catch during collect python modules</li> <li>Refactoring of C++ Python bridge</li> </ul>"},{"location":"changelog/#v040","title":"v0.4.0","text":"<ul> <li>Add events support in Python scripts</li> <li>Improve Python scripts run</li> <li>Add common libraries for a Python</li> <li>Fix memory leaks in core</li> <li>Improve test logging</li> <li>Improve work with memory buffers</li> <li>Cleanup API</li> <li>Add support of python 3 code</li> <li>Add <code>ScLockScope</code> class</li> <li>Implement multithreaded python script run</li> <li>Pass <code>cpp_bridge</code> into python script</li> <li>Extract <code>ScWaitEvent</code> as a separated class from <code>ScWait</code></li> <li>Some fixes in template search</li> <li>Make log thread safe</li> <li>Implement <code>ScLink</code> wrapper class</li> <li>Add <code>ScBase64</code> encode/decode functions</li> <li>Add common templates generation (see <code>sc_common_templ.hpp</code>)</li> </ul>"},{"location":"changelog/#v031","title":"v0.3.1","text":"<ul> <li>Fix templates search error (problems was with triples search order)</li> <li>Implement logging for load extension module problems</li> <li>Remove <code>nl</code>, <code>iot</code> modules from kpm, because they are project specific (moved to a separate repo)</li> <li>Add <code>ForEach</code> function into template search result</li> <li>Add <code>ForEachIter</code> functions into <code>ScMemoryContext</code></li> <li>Add <code>ScSet</code> class</li> <li>Add support of http requests</li> </ul>"},{"location":"changelog/#v030","title":"v0.3.0","text":"<ul> <li>Implement search for elements, that has no constancy flag in a type</li> <li>Fix template search error (#251)</li> <li>Fix problem with <code>SC_ASSERT</code> compilation in release mode (#249)</li> <li>Implement SCs-text parser (levels 1 - 4)</li> <li>Agent <code>AApiAiParseUserTextAgent</code> can run commands</li> <li>Implement common function to work with commands in knowledge base</li> <li>Add support of keynode types in codegenerator. Now you can specify type of keynode that would be used to create it: <code>ForceCreate(ScType::Node...)</code></li> <li>Rename module funcitons from <code>initialize</code>, <code>shutdown</code>, <code>load_priority</code> to <code>sc_module_initialize</code>, <code>sc_module_shutdown</code>, <code>sc_module_load_priority</code></li> <li>Update code to codestyle. Most functions was renamed from <code>functionName</code> to <code>FunctionName</code>. Iterator <code>value</code> function replaced with <code>Get</code>.</li> <li>Implement support of result codes for action agents</li> <li>Improve unit test system</li> <li>Add MkDocs documentation generator support</li> <li>Add <code>clang-format</code> config</li> <li>Add codestyle document</li> <li>Add documentation for <code>C++</code> API</li> <li>Implement multithreaded emit of sc-events</li> <li>Implement ref counter for sc-elements</li> <li>Cover whole functionality of <code>C++</code> API by unit tests</li> <li>Implement <code>C++</code> API</li> </ul>"},{"location":"docker/","title":"Installation with Docker","text":""},{"location":"docker/#using-sc-machine-inside-docker","title":"Using sc-machine inside Docker","text":"<p>All our releases are automatically uploaded to Docker Hub, so to start using our latest release it's enough to have Docker installed and configured (please note that Docker from <code>snap</code> and Debian's/Ubuntu's repo are known to be broken, install using the official guide).</p>"},{"location":"docker/#launch","title":"Launch","text":"<pre><code>docker compose run --rm machine build #build KB (see below for details)\ndocker compose up #launch server\n</code></pre> <p>Generally you would want to use a KB source folder alongside sc-machine. To do that, create a \"kb\" folder in the root of the project and place the KB sources in it. After that build it using the command described above (or enable autorebuild as shown below).</p> <p>Note: By default we expect you to place a repo.path file inside the <code>./kb</code> folder, but in case you don't have one you can configure to build the folder itself by modifying the <code>.env</code> file:</p> <pre><code>+KB_PATH=\"/kb\"\n</code></pre> <p>If you want to auto-rebuild the knowledge base on sc-server restart, you can also configure this behavior in the <code>.env</code> file:</p> <pre><code>+REBUILD_KB=1\n</code></pre>"},{"location":"docker/#docker_entrypointsh","title":"docker_entrypoint.sh","text":"<p>Our Docker entrypoint script has two commands: <code>build</code> and <code>serve</code>. The former is used to build or update knowledge base, and the latter is used to launch <code>sc-server</code>. You can use it in your own projects that use sc-server as the entrypoint. Don't forget to configure custom binary and knowledge base paths. Consult with the <code>docker-entrypoint.sh --help</code> for the full list of available flags.</p>"},{"location":"docker/#rebuild-image","title":"Rebuild image","text":"<p>In case you want to run your own, changed version of <code>sc-machine</code> or you made some contributions that require changes to the image, use our <code>Dockerfile</code> to build a new version of the image. To rebuild the image, launch <code>docker build . -t ostis/sc-machine</code> in the root folder of this project. You'll be able to launch it using <code>docker compose up</code> afterwards.</p>"},{"location":"license/","title":"License","text":"<p>Unless otherwise indicated, Source Code is licensed under MIT license.</p> <p>Copyright (c) 2010-2022 OSTIS</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"thirdparty/","title":"Thirdparty","text":""},{"location":"thirdparty/#code-generator","title":"Code generator","text":"<p>Based on refactored code from: CPP-Reflection</p>"},{"location":"thirdparty/#sc-memory","title":"Sc-memory","text":"<ul> <li>JSON for Modern C++</li> <li>Antlr 4</li> <li>libclang</li> <li>Websocketcpp</li> </ul>"},{"location":"build/cmake-flags/","title":"CMake Flags","text":""},{"location":"build/cmake-flags/#build-cache","title":"Build cache:","text":"<p>This project uses ccache automatically if it's available in the system. To disable this, use flag <code>-DAUTO_CCACHE=OFF</code></p>"},{"location":"build/cmake-flags/#building-tests","title":"Building tests:","text":"<pre><code>cd sc-machine\ncmake -B build -DSC_BUILD_TESTS=ON -DSC_AUTO_TEST=ON\ncmake --build build -j$(nproc)\n</code></pre> <p>Additionally you can use <code>-DSC_BUILD_BENCH=ON</code> flag to build performance tests</p>"},{"location":"build/cmake-flags/#building-with-sanitizers","title":"Building with sanitizers","text":"<p>Use <code>cmake</code> with <code>-DSC_USE_SANITIZER=memory</code> or <code>-DSC_USE_SANITIZER=address</code> option to run build with memory or address sanitizer.  Note: sanitizers are only supported by <code>clang</code> compiler </p>"},{"location":"build/cmake-flags/#example","title":"Example:","text":"<pre><code>cd sc-machine\ncmake -B build -DSC_USE_SANITIZER=memory -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang\ncmake --build build\n</code></pre>"},{"location":"build/cmake-flags/#code-formatting-with-clangformat","title":"Code formatting with CLangFormat:","text":"<p>To check code with CLangFormat run: <pre><code>cd sc-machine\ncmake -B build -DSC_CLANG_FORMAT_CODE=ON\ncmake --build build --target clangformat_check\n</code></pre></p> <p>or <pre><code>cd sc-machine\n./scripts/clang/check_formatting.sh\n</code></pre></p> <p>To format code with CLangFormat run: <pre><code>cd sc-machine\ncmake -B build -DSC_CLANG_FORMAT_CODE=ON\ncmake --build build --target clangformat\n</code></pre></p> <p>or <pre><code>cd sc-machine\n./scripts/clang/format_code.sh\n</code></pre></p>"},{"location":"build/linux-build/","title":"Build on Linux","text":"<p>This instruction is intended to be used on Debian-based distros. For other distros, skip Install dependencies section and make sure you install all the required packages manually.</p>"},{"location":"build/linux-build/#clone","title":"Clone","text":"<pre><code>git clone https://github.com/ostis-ai/sc-machine.git\ncd sc-machine\ngit submodule update --init --recursive\n</code></pre>"},{"location":"build/linux-build/#install-dependencies","title":"Install dependencies","text":"<pre><code>cd scripts\n./install_deps_ubuntu.sh --dev\n</code></pre>"},{"location":"build/linux-build/#build","title":"Build","text":"<pre><code>cd sc-machine\ncmake -B build -DCMAKE_BUILD_TYPE=Release # use Debug for debug build\ncmake --build build -j$(nproc)\n</code></pre> <p>Alternatively, you can use a script: <pre><code>cd sc-machine/scripts\n./make_all.sh #You can also pass all CMake generation arguments there\n</code></pre> Note: by default the binary outputs are saved in the <code>bin</code> folder, it is located at the same level as CMake build tree (the <code>build</code> folder). If you've generated the build tree in a location different from the root folder of the project, you may need to change further commands in the tutorial to accommodate for changed <code>bin</code> folder location.</p>"},{"location":"build/osx-build/","title":"Build on OSX","text":""},{"location":"build/osx-build/#clone","title":"Clone","text":"<pre><code>git clone https://github.com/ostis-ai/sc-machine.git\ncd sc-machine\ngit submodule update --init --recursive\n</code></pre>"},{"location":"build/osx-build/#install-dependencies","title":"Install dependencies","text":"<p>Note: you will need Homebrew installed and configured on your Mac.</p> <pre><code>cd scripts\n./install_deps_macOS.sh\ncd ..\npip3 install -r requirements.txt\n</code></pre>"},{"location":"build/osx-build/#build","title":"Build","text":"<pre><code>cd sc-machine\ncmake -B build -DCMAKE_BUILD_TYPE=Release # use Debug for debug build\ncmake --build build -j$(nproc)\n</code></pre> <p>Note: by default the binary outputs are saved in the <code>bin</code> folder, it is located at the same level as CMake build tree (the <code>build</code> folder). If you've generated the build tree in a location different from the root folder of the project, you may need to change further commands in the tutorial to accommodate for changed <code>bin</code> folder location.</p>"},{"location":"cpp/common/","title":"Common","text":""},{"location":"cpp/common/#sclink","title":"ScLink","text":"<p>Include file: <code>#include &lt;sc-memory/cpp/sc_link.hpp&gt;</code></p> <p>There is a special wrapped class <code>ScLink</code> that makes work with sc-links simple. It allows to set/get common types values. Supported types: <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code>, <code>uint64_t</code>, <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, <code>int64_t</code>, <code>float</code>, <code>double</code>, <code>std::string</code>.</p> If you try to get <code>Type1</code> value, but in memory stores <code>Type2</code> value, then function <code>Get&lt;Type&gt;()</code> will throws an exception <code>ExceptionInvalidParams</code> <p>Example: <pre><code>...\nstd::string const str = \"any text value\";\nScLink link(linkAddr);\nlink.Set(str);\nlink.IsType&lt;std::string&gt;(); // will return true\nstd::string const value = link.Get&lt;std::string&gt;(); // value == str\n...\nuint32_t const ivalue = 473;\nlink.Set(ivalue);\nlink.IsType&lt;std::string&gt;(); // returns false\nlink.IsType&lt;uint32_t&gt;(); // returns true\nlink.IsType&lt;uint8_t&gt;(); // returns false\n...\nlink.Get&lt;std::string&gt;(); // throws ExceptionInvalidParams\nlink.Get&lt;uint32_t&gt;(); // returns stored value\nlink.IsType&lt;uint8_t&gt;(); // throws ExceptionInvalidParams\n...\n</code></pre></p> <p>Also you can get type of specified <code>ScLink</code>: <pre><code>ScLink link;\nlink.Set&lt;uint32_t&gt;(32);\nlink.DetermineType(); // will return ScLink::Type::UInt32\n</code></pre></p> <p>See <code>ScLink::Types</code> for full list of supported ones.</p> <p>You can get value of any ScLink as <code>std::string</code>: <pre><code>ScLink link;\nlink.Set&lt;uint32_t&gt;(32);\nlink.GetAsString(); // will return \"32\"\n</code></pre></p>"},{"location":"cpp/common/#common-constructions","title":"Common constructions","text":"<p>Include file: <code>#include &lt;sc-memory/cpp/sc_common_templ.hpp&gt;</code></p> <p>There are some function that allows to make a common routine work:</p> <ul> <li><code>sc::ResolveRelationTuple</code> - allow to ensure that specified <code>quasy_binary</code> relation between tuple and specified element exists. Returns <code>ScAddr</code> of tuple. This function check if specified construction exists, and if it doesn't then generate it by template. Used template for check/generation: </li> </ul> <p>Example: <pre><code>ScAddr const tuple = sc::ResolveRelationTuple(ctx, el, relAddr);\n// where:\n// el - is a ScAddr of element to ensure tuple exist\n// relAddr - is a ScAddr of quasy_binary relation\n</code></pre></p> <ul> <li><code>sc::SetRelationValue</code> - create sc-link linked to <code>el</code> by relation <code>rel</code>. If it already exist, than changes it value to new one. Returns <code>ScAddr</code> of sc-link. Used template for check/generation: </li> </ul> <p>Example: <pre><code>std::string const value1 = \"test_value\";\nScAddr const linkAddr1 = sc::SetRelationValue(ctx, el, relAddr1, value1);\nuint32_t const value2 = 57;\nScAddr const linkAddr2 = sc::SetRelationValue(ctx, el, relAddr1, value2);\nSC_ASSERT(linkAddr1 == linkAddr2, ()); // should be valid (ScAddr of link doesn't changed)\n</code></pre></p>"},{"location":"cpp/common/#iterators","title":"Iterators","text":"<p>You can use 3-element iterators and 5-element iterators from c++ code. Image below shows numeration of elements in 3-element (left) and 5-element (right) iterators. </p> <p>For both of them you have two approaches. First approach to use simple while loop. It suitable, when you need to break this loop depending on logic: <pre><code>...\n// example of f_a_a iterator\nScIterator3Ptr it3 = ctx.Iterator3(\nset,\nScType::EdgeAccessConstPosPerm,\nScType::Unknown);\nwhile (it3-&gt;Next())\n{\n// to get values use it3-&gt;Get(index), where index in range [0; 2]\n... // there is you code\n}\n...\n// example of f_a_a_a_f iterator\nScIterator5Ptr it5 = ctx.Iterator5(\nobjAddr,\nScType::EdgeDCommonConst,\nScType::NodeConstAbstract,\nScType::EdgeAccessConstPosPerm,\nKeynodes::nrel_mass);\nwhile (it5-&gt;Next())\n{\n// to get values use it5-&gt;Get(index), where index in range [0; 4]\n... // there is you code\n}\n</code></pre></p> <p>Second approach allows you iterate 3-element and 5-element constructions with less code, and suitable when you need to iterate all results. Use it if you need to iterate all results. Because it more clearly. <pre><code>...\nctx.ForEachIter3(\nset,\nScType::EdgeAccessConstPosPerm,\nScType::Unknown,\n[] (ScAddr const &amp; src, ScAddr const &amp; edge, ScAddr const &amp; trg)\n{\n// src equal to 0 value of iterator\n// edge equal to 1 value of iterator\n// trg equal to 2 value of iterator\n... // there is you code\n});\n...\nctx.ForEachIter5(\nobjAddr,\nScType::EdgeDCommonConst,\nScType::NodeConstAbstract,\nScType::EdgeAccessConstPosPerm,\nKeynodes::nrel_mass\n[] (ScAddr const &amp; src, ScAddr const &amp; edge, ScAddr const &amp; trg, ScAddr const &amp; edgeAttr, ScAddr const &amp; attr)\n{\n// src equal to 0 value of iterator\n// edge equal to 1 value of iterator\n// trg equal to 2 value of iterator\n// edgeAttr equal to 3 value of iterator\n// attr equal to 4 value of iterator\n... // there is you code\n});\n</code></pre></p>"},{"location":"cpp/common/#http","title":"HTTP","text":"<p>You can use <code>ScHttpRequest</code> class to make requests using <code>HTTP</code> protocol: <pre><code>...\nScHttpRequest request(\"http://any.url\");\nrequest.SetType(ScHttpRequest::Type::POST);\nrequest.SetData(\"any data\");\nrequest.AddHeader(\"Content-Type: application/json\");\nrequest.AddHeader(...);\nrequest.Perform();\nauto const response = request.GetResponse();\nif (response.IsPtrValid() &amp;&amp; response-&gt;IsSuccess())\n{\nauto const &amp; responseStr = response-&gt;GetData();\n// process responseStr\nreturn true;\n}\n...\n</code></pre></p>"},{"location":"cpp/cpp-meta/","title":"Meta programming","text":"<p>There is a code generator that allows to create some common code by using metadata. It runs before code compilation and generate files with a name <code>&lt;header_name&gt;.generated.&lt;header_extension&gt;</code>. For example if you run it for a file <code>text.h</code> it would produce a file <code>text.generated.h</code></p> <p>To make a metadata for you code you can use this set of macros: * SC_CLASS - allows you to specify metadata for a class; * SC_GENERATED_BODY - macros that need to be used after SC_CLASS, because it would be replaced in during compilation time with generated declaration for this class; * SC_PROPERTY - allows to specify metadata for members of a class (including static members).</p> <p>You should to specify SC_CLASS and SC_GENERATED_BODY for all child classes of ScObject</p>"},{"location":"cpp/cpp-meta/#syntax","title":"Syntax","text":"<p>There is a syntax rule that used for a metadata specification: <pre><code>[&lt;PropertyName&gt; [ (&lt;PropertyValue&gt;, &lt;PropertyValue&gt;, ...) ] ], \u2026\n</code></pre></p> <p>For example:</p> <p><pre><code>SC_CLASS(Agent, CmdClass(\"command_update_power_usage\"))\n</code></pre> <pre><code>SC_CLASS(CmdClass(\"command_generate_text_from_template\"), Agent)\n</code></pre> <pre><code>SC_PROPERTY(Keynode(\"nrel_real_energy_usage\"), ForceCreate)\n</code></pre> <pre><code>SC_CLASS(Agent, Event(ActionManager::msActionPeriodical, SC_EVENT_ADD_OUTPUT_ARC))\n</code></pre></p> <p>You should to use SC_CLASS and SC_GENERATED_BODY in class declaration: <pre><code>class AWhoAreYouAgent : public ScAgentAction\n{\nSC_CLASS(Agent, CmdClass(\"command_who_are_you\"))\nSC_GENERATED_BODY()\n};\n</code></pre></p>"},{"location":"cpp/cpp-meta/#classes","title":"Classes","text":"<p>Table of available properties of class metadata (SC_CLASS):</p> Property Description Agent Parent class: ScAgent and all childs       You should always use it for all ScAgent child classes      CmdClass Determine system identifier of command class that implemented by sc-agent.     Parent class: ScAgentAction     Arguments: <ul> <li>System identifier of command class.</li> </ul> <pre><code>\nclass AAddContentAgent : public ScAgentAction\n{\n SC_CLASS(Agent, CmdClass(\"command_add_content\"))\n SC_GENERATED_BODY()\n};\n    </code></pre> Event Specify condition to start sc-agent implementation. Parent class: ScAgent       Arguments: <ul> <li>ScAddr of element which will be used to subscribe for an event;</li> <li>ScEventType type of event to subscribe.</li> </ul>       Another words, we specify sc-element and event on it, that runs implementation of sc-agent. Possible event types:       <ul> <li>SC_EVENT_ADD_OUTPUT_ARC</li> <li>SC_EVENT_ADD_INPUT_ARC</li> <li>SC_EVENT_REMOVE_OUTPUT_ARC</li> <li>SC_EVENT_REMOVE_INPUT_ARC</li> <li>SC_EVENT_REMOVE_ELEMENT</li> <li>SC_EVENT_CONTENT_CHANGED</li> </ul> <pre><code>\nclass ANewPeriodicalActionAgent : public ScAgent\n{\n SC_CLASS(Agent, Event(msActionPeriodical, SC_EVENT_ADD_OUTPUT_ARC))\n SC_GENERATED_BODY()\n};\n      </code></pre> LoadOrder Specify order (priority) of module loading. Can be used just in ScModule child classes.       Parent class: ScModule       Arguments: <ul> <li>Priority as unsigned int number</li> </ul>       System loads modules by ascending order. If two module has an equal load order, then they can load in any order (relative to each other).        <pre><code>\nclass nlModule : public ScModule\n{\n SC_CLASS(LoadOrder(11))\n SC_GENERATED_BODY()\n\n sc_result initializeImpl();\n sc_result shutdownImpl();\n};\n      </code></pre>"},{"location":"cpp/cpp-meta/#members","title":"Members","text":"<p>Table of available properties of class members metadata (SC_PROPERTY):</p> Property Description Keynode Arguments: <ul> <li>String with system identifier of sc-element.</li> </ul>       Specify that this member is a keynode. After module starts, this member will contains ScAddr of specified sc-element or invalid ScAddr if sc-element not found. Just add ForceCreate to create sc-element in case when it didn't found.       You can use this property just for members that has ScAddr type.        <pre><code>\nSC_PROPERTY(Keynode(\"device\"), ForceCreate)\nstatic ScAddr m_device;\n      </code></pre> Template Arguments: <ul> <li>String system identifier of template sc-structure in sc-memory</li> </ul>       Specify that this member is a template. After module starts, this template will be parsed from sc-memory. So you will be able use it to search/generate constructions.       You can use this property just for members that has ScTemplate type.        <pre><code>\nSC_PROPERTY(Template(\"test_template\"))\nScTemplate m_testTemplate;\n      </code></pre> ForceCreate Arguments: <ul> <li>[optional] type of sc-element. Any value from `ScType::Node...`</li> </ul> Used just with Keynode property. Using of this property force sc-element creation, if it didn't found by system identifier.        <pre><code>\nSC_PROPERTY(Keynode(\"device\"), ForceCreate(ScType::NodeConstClass))\nstatic ScAddr m_device;\n\nSC_PROPERTY(Keynode(\"device\"), ForceCreate) // default value ScType::Node\nstatic ScAddr m_node;\n      </code></pre>"},{"location":"cpp/cpp-meta/#faq","title":"FAQ","text":"<ol> <li>How to include one <code>MyObject</code> into <code>OtherObject</code> <pre><code>/* In CPP file you should include header file for object, that implemented in this file\n * For example in file MyObject.cpp we should make order\n */\n#include \"otherObject.hpp\"\n#include \"otherObject2.hpp\"\n...\n#include \"myObject.hpp\"\n// other includes (that doesn't contains ScObject derived classes)\n...\n// Implementation\n...\n</code></pre></li> </ol>"},{"location":"cpp/el_types/","title":"Element types","text":"<p>TODO: Describe types there</p> <p>TODO: Types compare during search</p> Graphical (SCg) C C++ sc_type_node ScType::Node sc_type_node | sc_type_const ScType::NodeConst sc_type_node | sc_type_var ScType::NodeVar sc_type_node | sc_type_const | sc_type_node_tuple ScType::NodeConstTuple sc_type_node | sc_type_var | sc_type_node_tuple ScType::NodeVarTuple sc_type_node | sc_type_const | sc_type_node_struct ScType::NodeConstStruct sc_type_node | sc_type_var | sc_type_node_struct ScType::NodeVarStruct sc_type_node | sc_type_const | sc_type_node_role ScType::NodeConstRole sc_type_node | sc_type_var | sc_type_node_role ScType::NodeVarRole sc_type_node | sc_type_const | sc_type_node_norole ScType::NodeConstNorole sc_type_node | sc_type_var | sc_type_node_norole ScType::NodeVarNorole sc_type_node | sc_type_const | sc_type_node_class ScType::NodeConstClass sc_type_node | sc_type_var | sc_type_node_class ScType::NodeVarClass sc_type_node | sc_type_const | sc_type_node_abstract ScType::NodeConstAbstract sc_type_node | sc_type_var | sc_type_node_abstract ScType::NodeVarAbstract sc_type_node | sc_type_const | sc_type_node_material ScType::NodeConstMaterial sc_type_node | sc_type_var | sc_type_node_material ScType::NodeVarMaterial sc_type_edge_common ScType::EdgeUCommon sc_type_arc_common ScType::EdgeDCommon sc_type_edge_common | sc_type_const ScType::EdgeUCommonConst sc_type_edge_common | sc_type_var ScType::EdgeUCommonVar sc_type_arc_common | sc_type_const ScType::EdgeDCommonConst sc_type_arc_common | sc_type_var ScType::EdgeDCommonVar sc_type_arc_access ScType::EdgeAccess sc_type_arc_access | sc_type_const | sc_type_arc_pos | sc_type_arc_perm ScType::EdgeAccessConstPosPerm sc_type_arc_access | sc_type_var | sc_type_arc_pos | sc_type_arc_perm ScType::EdgeAccessVarPosPerm sc_type_arc_access | sc_type_const | sc_type_arc_neg | sc_type_arc_perm ScType::EdgeAccessConstNegPerm sc_type_arc_access | sc_type_var | sc_type_arc_neg | sc_type_arc_perm ScType::EdgeAccessVarNegPerm sc_type_arc_access | sc_type_const | sc_type_arc_fuz | sc_type_arc_perm ScType::EdgeAccessConstFuzPerm sc_type_arc_access | sc_type_var | sc_type_arc_fuz | sc_type_arc_perm ScType::EdgeAccessVarFuzPerm sc_type_arc_access | sc_type_const | sc_type_arc_pos | sc_type_arc_temp ScType::EdgeAccessConstPosTemp sc_type_arc_access | sc_type_var | sc_type_arc_pos | sc_type_arc_temp ScType::EdgeAccessVarPosPerm sc_type_arc_access | sc_type_const | sc_type_arc_neg | sc_type_arc_temp ScType::EdgeAccessConstNegTemp sc_type_arc_access | sc_type_var | sc_type_arc_neg | sc_type_arc_temp ScType::EdgeAccessVarNegPerm sc_type_arc_access | sc_type_const | sc_type_arc_fuz | sc_type_arc_temp ScType::EdgeAccessConstFuzTemp sc_type_arc_access | sc_type_var | sc_type_arc_fuz | sc_type_arc_temp ScType::EdgeAccessVarFuzPerm"},{"location":"dev/codestyle/","title":"C++ Style Guide","text":"<p>In general, Google's coding standard is used, and we strongly encourage to read it.</p> <p>Below are our specific (but not all!) exceptions to the Google's coding standard:</p> <ul> <li>All code should conform to C++17 standard</li> <li>We use <code>.cpp</code> and <code>.hpp</code> files, not <code>.cc</code> and <code>.h</code> (<code>.c</code> and <code>.h</code> are used for C code), in UTF-8 encoding.</li> <li>File names are lowercase with underscores, like <code>sc_memory.cpp</code>.</li> <li>We use <code>#pragma once</code> instead of the <code>#define</code> Guard in header files.</li> <li>Includes are sorted and grouped by directory, there should be newlines between different directories.</li> <li>Order of directories in includes: \"current_dir/current_file.hpp\", other includes from the same dir, includes from other dirs sorted by name.</li> </ul> <pre><code>#include \"../test.hpp\"\n#include \"hash/hmac.h\"\n#include \"hash/sha256.h\"\n#include \"sc-memory/cpp/sc_wait.hpp\"\n#include \"sc-memory/cpp/kpm/sc_agent.hpp\"\n#include &lt;curl/curl.h&gt;\n#include &lt;rapidjson/document.h&gt;\n#include &lt;rapidjson/stringbuffer.h&gt;\n#include &lt;rapidjson/writer.h&gt;\n</code></pre> <ul> <li>We ARE using C++ exceptions.</li> <li>We are using all features of C++17.</li> </ul> <p>Naming and formatting</p> <ul> <li>We ALWAYS use two spaces indent and don't use tabs. If you see old formated file, then change format of it in separated commit.</li> <li>We don't have hardcoded line width, but keep it reasonable to fit on the screen.</li> <li>Doxygen-style comments can be used.</li> <li>Underscores are allowed only in prefixes for member variables and namespace names, like <code>int m_keynodeAddr; namespace sc_utils</code>.</li> <li>Don't use <code>using namespace std</code> or other namepsaces globaly. You can use them localy in test cpp files or functions.</li> <li>Use right-to-left order for variables/params: <code>ScAddr const &amp; addr</code> (reference to the const <code>ScAddr</code>).</li> <li>In one line <code>if</code>, <code>for</code>, <code>while</code> we do not use brackets. If one line <code>for</code> or <code>while</code> is combined with one line <code>if</code>, do use brackets for cycle.</li> </ul> <pre><code>for (ScAddr const &amp; addr : listOfAddr)\nctx.EraseElement(addr);\n...\nfor (ScAddr const &amp; addr : listOfAddr)\n{\nif (addr.IsValid())\nreturn true;\n}\n</code></pre> <ul> <li>Space after the keyword in conditions and loops. Space after <code>;</code> in <code>for</code> loop.</li> <li>Space between binary operators: <code>x = y * y + z * z</code>.</li> <li>Space after double dash <code>x = isValid ? 2 : 1;</code>.</li> <li>We use <code>using</code> keyword instead of <code>typedef</code>.</li> <li>Compile-time constants must be named in camelCase, starting with a lower-case <code>k</code>, e.g. <code>kCompileTimeConstant</code> and marked as <code>constexpr</code> when possible.</li> <li>Values of enum classes must be named in CamelCase, e.g. <code>enum class Color { Red, Green, LightBlue };</code>.</li> <li> <p>Macros and C-style enums must be named in UPPER_CASE, and enum values must be prefixed with a capitalized enum name.</p> <p>Note that macros complicate debugging, and old-style enums have dangerous implicit conversions to integers, and tend to clutter containing namespaces. Avoid them when possible - use <code>const</code> or <code>constexpr</code> instead of macros, and enum classes instead of enums.</p> </li> </ul> <p>Code should compile without warnings!. Just deprecated warning could be present for a short time. But if you see them, then try to fix it in a separate commit</p>"},{"location":"dev/codestyle/#clangformat","title":"ClangFormat","text":"<p>Most of our coding style is specified in a configuration file for ClangFormat. To automatically format a file, install <code>clang-format</code> and run:</p> <pre><code>clang-format -i file.cpp file.hpp other_file.cpp\n</code></pre>"},{"location":"dev/codestyle/#formatting-exampleguidereference","title":"Formatting Example/Guide/Reference","text":"<pre><code>#pragma once\n#include \"sc_addr.hpp\"\nuint16_t constexpr kBufferSize = 255;\n// C-style enums are ALL_CAPS. But remember that C++11 enum classes are preferred.\nenum Type\n{\nTYPE_INTEGER,\nTYPE_FLOAT,\nTYPE_STRING\n};\nusing TMyTypeStartsWithCapitalTLetter = double;\nclass ComplexClass\n{\npublic:\nComplex(double rePart, double imPart) : m_re(rePart), m_im(imPart) {}\ndouble Modulus() const\n{\ndouble const rere = m_re * m_re;\ndouble const imim = m_im * m_im;\nreturn sqrt(rere + imim);\n}\ndouble OneLineMethod() const { return m_re; }\nprivate:\n// We use m_ prefix for member variables.\ndouble m_re;\ndouble m_im;\n};\nnamespace\n{\nvoid CamelCaseFunctionName(int lowerCamelCaseVar)\n{\nstatic int counter = 0;\ncounter += lowerCamelCaseVar;\n}\n}  // namespace\nnamespace lower_case\n{\ntemplate &lt;class TTemplateTypeStartsWithCapitalTLetter&gt;\nvoid SomeFoo(int a, int b,\nTTemplateTypeStartsWithCapitalTLetter /* We avoid compilation warnings. */)\n{\nfor (int i = 0; i &lt; a; ++i)\n{\n// IMPORTANT! We DON'T use one-liners for if statements for easier debugging.\n// The following syntax is invalid: if (i &lt; b) Bar(i);\nif (i &lt; b)\nBar(i);\nelse\n{\nBar(i);\nBar(b);\n// Commented out the call.\n// Bar(c);\n}\n}\n}\n}  // namespace lower_case\n// Switch formatting.\nint Foo(int a)\n{\nswitch (a)\n{\ncase 1:\nBar(1);\nbreak;\ncase 2:\n{\nBar(2);\nbreak;\n}\ncase 3:\ndefault:\nBar(3);\nbreak;\n}\nreturn 0;\n}\n// Loops formatting.\nif (condition)\nfoo();\nelse\nbar();\nif (condition)\n{\nif (condition)\nfoo();\nelse\nbar();\n}\nfor (size_t i = 0; i &lt; size; ++i)\nfoo(i);\nwhile (true)\n{\nif (condition)\nbreak;\n}\n// Space after the keyword.\nif (condition)\n{\n}\nfor (size_t i = 0; i &lt; 5; ++i)\n{\n}\nwhile (condition)\n{\n}\nswitch (i)\n{\n}\n// Space between operators, and don't use space between unary operator and expression.\nx = 0;\nx = -5;\n++x;\nx--;\nx *= 5;\nif (x &amp;&amp; !y)\n{\n}\nv = w * x + y / z;\nv = w * (x + z);\n// Space after double dash. And full sentences in comments.\n</code></pre>"},{"location":"dev/codestyle/#tips-and-hints","title":"Tips and Hints","text":"<ul> <li>If you see outdated code which can be improved - DO IT NOW (but in the separate pull request).</li> <li>Your code should work at least on: Ubuntu 20.04 and 22.04; Debian 11; MacOS platforms.</li> <li>Your code should compile well with the last gcc and clang.</li> <li>Try to avoid using any new 3rd party library if it is not fully tested and supported on supported platforms.</li> <li>Cover your code with unit tests.</li> <li>If you don't have enough time to make it right, leave a <code>// TODO(DeveloperName): need to fix it</code> comment.</li> </ul>"},{"location":"dev/codestyle/#some-useful-macros","title":"Some useful macros:","text":"<ul> <li>macroses to check compilation platform</li> </ul> <p><pre><code>#if SC_IS_PLATFORM_WIN32\n// windows platform\n#endif\n#if SC_IS_PLATFORM_LINUX\n// linux platform\n#endif\n#if SC_IS_PLATFORM_MAC\n// OSX (mac) platform\n#endif\n#if SC_IS_PLATFORM_IOS\n// iOS platform\n#endif\n#if SC_IS_PLATFORM_ANDROID\n// android platform\n#endif\n</code></pre> - Check code in runtime for Debug builds:</p> <pre><code>SC_ASSERT(expr, (\"message\"));\nSC_ASSERT(expr, ()); // no message\n</code></pre> <ul> <li>Check if code compiles in Debug mode:</li> </ul> <pre><code>#if SC_DEBUG_MODE\n// compiles in debug\n#endif\n</code></pre> <ul> <li>Check code in runtime for any type of build. Prefer <code>SC_CHECK_...</code> to <code>SC_CHECK</code>:</li> </ul> <pre><code>SC_CHECK(expr, (\"message\"));\nSC_CHECK(expr, ()); // no message\nSC_CHECK_NOT(expr, ()); // equal to SC_CHECK(!expr, ());\nSC_CHECK_EQUAL(a, b, ()); // equal to SC_CHECK(a == b, ());\nSC_CHECK_NOT_EQUAL(a, b, ()); // equal to SC_CHECK(a != b, ());\nSC_CHECK_GREAT(a, b, ()); // equal to SC_CHECK(a &gt; b, ());\nSC_CHECK_GREAT_EQ(a, b, ()); // equal to SC_CHECK(a &gt;= b, ());\nSC_CHECK_LESS(a, b, ()); // equal to SC_CHECK(a &lt; b, ());\nSC_CHECK_LESS_EQ(a, b, ()); // equal to SC_CHECK(a &lt;= b, ());\n</code></pre> <ul> <li>Logging:</li> <li><code>SC_LOG_DEBUG(msg)</code> - print message in Debug builds. Prefix: <code>[Debug]</code></li> <li><code>SC_LOG_INFO(msg)</code></li> <li><code>SC_LOG_WARNING(msg)</code></li> <li><code>SC_LOG_ERROR(msg)</code></li> <li> <p><code>SC_LOG_INFO_COLOR(msg, color)</code> - print colored info message. Look color constants in <code>ScConsole::Color</code></p> </li> <li> <p>Declare your own exceptions:</p> </li> </ul> <p><pre><code>class MyException final : public ScException\n{\npublic:\nexplicit MyException(std::string const &amp; msg) : ScException(\"My: \" + msg) {}\n};\n</code></pre> - Throw exceptions with <code>SC_THROW_EXCEPTION(exceptionName, message)</code>:</p> <pre><code>SC_THROW_EXCEPTION(MyException, \"my message\")\n</code></pre> <ul> <li>Exception for a non implemented parts of code <pre><code>SC_NOT_IMPLEMENTED(\"message\")\n</code></pre></li> </ul>"},{"location":"dev/devcontainer/","title":"Dev container","text":""},{"location":"dev/devcontainer/#docker-development-container","title":"Docker development container","text":"<p>We recognize that recreating development environment for this project may be complicated, especially on unsupported platforms. To ease things for our developers and contributors, we created a stable, reproducible environment dubbed \"Dev container\". It can be used in any IDE or in a standalone manner, but is fully integrated with Visual Studio Code. </p>"},{"location":"dev/devcontainer/#usage","title":"Usage","text":""},{"location":"dev/devcontainer/#vscode","title":"VSCode","text":"<p>If you use VSCode as your code editor of choice, things are simple: install Docker, install <code>Remote - Containers</code> extension for VSCode, and reload the window. You should see a prompt to reopen the project in container (if it didn't appear, you can fire up <code>Reopen in Container</code> action in Command Palette). First load/build may take a while, so don't rush to cancel the process. After the window is reopened, you can open terminals, edit code and recompile the project as usual.</p>"},{"location":"dev/devcontainer/#jetbrains-ide","title":"JetBrains IDE","text":"<p>You can add our development environment container as a Docker toolchain to your JetBrains IDE. Check this guide for more info.</p>"},{"location":"dev/devcontainer/#standalone","title":"Standalone","text":"<p>Using this image directly in the terminal is also possible:</p> <ol> <li> <p>To build it, use <code>devcontainer</code> target in our Dockerfile <pre><code>docker build . -t ostis/sc-machine-builder  --target=devcontainer\n</code></pre></p> </li> <li> <p>Run the container mounting your workspace folder to <code>/sc-machine</code> inside the container. Optionally you can create a volume for <code>ccache</code> to preserve build cache across restarts: <pre><code>docker run --rm -i -t -v sc-machine_ccache:/ccache -v &lt; path to the project folder&gt;:/sc-machine ostis/sc-machine-builder\n</code></pre></p> </li> </ol>"},{"location":"dev/git-workflow/","title":"Git-workflow","text":""},{"location":"dev/git-workflow/#initialize","title":"Initialize","text":"<p>To initialize your repo do:  * make fork from <code>https://github.com/ostis-ai/sc-machine</code>  * clone your fork to your machine and prepare <pre><code>git clone git@github.com:yourlogin/sc-machine.git\ncd sc-machine\ngit config --global user.name \"Your Name\"\ngit config --global user.email youremail@example.com\ngit remote add upstream git@github.com:ostis-ai/sc-machine.git\n</code></pre></p>"},{"location":"dev/git-workflow/#update","title":"Update","text":"<p>To update your master from <code>upstream</code> use: <pre><code>git fetch upstream\ngit checkout master\ngit merge upstream/master\ngit push origin master\n</code></pre></p>"},{"location":"dev/git-workflow/#rebase","title":"Rebase","text":"<p>To rebase your branch to master: <pre><code>git checkout yourbranch\ngit rebase master\n</code></pre></p> <p>If you have any problems, then: * redo <pre><code>git rebase --abort\n</code></pre> * ask in  </p>"},{"location":"dev/git-workflow/#common-rules","title":"Common rules","text":"<ul> <li>use <code>git rebase</code> instead of <code>merge</code>. More documentation about this command This command just try to apply your commits (from current branch to commits in specified branch)</li> </ul>"},{"location":"dev/git-workflow/#git-hooks","title":"Git hooks","text":"<p>To setup <code>pre-commit</code> hook run: <pre><code>cd sc-machine\npre-commit install\n</code></pre></p>"},{"location":"other/config/","title":"Configuration files","text":""},{"location":"other/config/#config-file-example","title":"Config file example:","text":"<p><pre><code>[sc-memory]\n# Maximum number of segments. By default: 65536\nmax_loaded_segments = 1000\n# Maximum number of threads that can be used to access to sc-memory. By default: 32\nmax_threads = 32\n# Maximum number of threads that can be used in events and agents handler. By default: core number of device processor\nmax_events_and_agents_threads = 32\n# Period (in seconds) to save sc-memory statistics\nsave_period = 3600\n# Period (in seconds) to update sc-memory statistics\nupdate_period = 1800\n# Path to compiled knowledge base folder (kb.bin should be inside this folder)\nrepo_path = /path/to/kb.bin\n# Path to sc-memory shared library extensions\nextensions_path = /path/to/sc-machine/bin/extensions\n# Maximum number of channels to split file memory into sections. By default: 1000\nmax_strings_channels = 1000\n# Maximum file memory section size. By default: 100000\nmax_strings_channel_size = 100000\n# Maximum size of strings that can be found by substring. By default: 1000\nmax_searchable_string_size = 1000\n# Separators used to divide strings into tokens to find this strings by its tokens substrings. By default: \" _\"\n# If search by substring isn't needed, set this value to \"\" to increase maximum performance for strings linking and searching\nterm_separators = \" _\" # If search by substring isn't needed, set this value to \"false\" to increase maximum performance for strings linking\nsearch_by_substring = true\n[sc-server]\n# Sc-server socket data\nhost = 127.0.0.1\nport = 8090\n# Sc-server log file\nlog_file = /path/to/sc-machine/log/sc-server.log\n# Sc-server log file\nlog_level = Info # it can be 'Debug' or 'Error' also\n# Sc-server mode to synchronize all actions in it\nsync_actions = 0\n</code></pre> Note: If you use relative paths they will be resolved based on config file location.</p>"},{"location":"other/repofile/","title":"KB repo file","text":""},{"location":"other/repofile/#knowledge-base-repository-file-repopath","title":"Knowledge base repository file - repo.path","text":"<p>For more complex KB setups (with several folders across the filesystem, for example), we've created an internal file format called <code>repo.path</code>. It allows you to specify all the folders that should be built into the KB or exclude some files or subfolders.</p>"},{"location":"other/repofile/#example","title":"Example","text":"<pre><code># Comments should start with hashtag as a first character in the line\n# Here you can specify path to one or several kb folders\n# Paths can be relative\n../ims.ostis.kb\n/full/path/to/kb\n../custom_kb\n# you can also exclude files or folders by adding a \"!\" symbol at the beginning of the line\n!../ims.ostis.kb/ims/ostis_tech\n!../custom_kb/test.scs\n</code></pre>"},{"location":"other/scs/","title":"SCs language","text":""},{"location":"other/scs/#common","title":"Common","text":"<p>SCs-code - is a text representation of SC-code. Whole text consist of sentences, that separated by <code>;;</code> symbols.</p>"},{"location":"other/scs/#comments","title":"Comments","text":"<p>You can use C-style comments in SCs text: <pre><code>// one line comment\nfruit -&gt; apple;\n/* Multiline\n * comment\n */\n</code></pre></p>"},{"location":"other/scs/#link-to-files","title":"Link to files","text":"<p>To make an <code>sc-link</code> into specified file you can use special type identifier: <pre><code>\"file://&lt;file name&gt;\"\n</code></pre></p> <ul> <li><code>\"file://&lt;file name&gt;\"</code> - is a relative path to a file. According to a file, where it used;</li> <li><code>\"file:///&lt;file_name&gt;\"</code> - is an absolute path to a file.</li> </ul>"},{"location":"other/scs/#names","title":"Names","text":"<p>There are some tricks with object names:</p> <ul> <li><code>...</code> - is an unnamed object;</li> <li><code>_&lt;object name&gt;</code> - all object names, that starts with symbol <code>_</code> represents a variable type of objects.</li> </ul> <p>Objects identifier visibility. By default all objects with name <code>x</code> are visible anywhere. After translating it into memory this object will have a system identifier equal to <code>x</code>. So if you use <code>x</code> in different scs files, then you designate the same object in them (would be the same element in a knowledge base).</p> <p>Sometimes you need to designate the same objects in different files, but do not generate a system identifier in memory for it. In this case you should to prefix it name with a <code>.</code> symbol. For example: <code>.x</code>.</p> <p>In case, when you need to make a named object just local for an scs file, then you should to use <code>..</code> prefix (example: <code>..x</code>).</p> <p>So a rule to build identifier is:</p> <pre><code>[visibility][variable]&lt;identifier&gt;\n</code></pre> <p>For example identifier <code>.._x</code> localy visible variable identifier.</p>"},{"location":"other/scs/#aliases","title":"Aliases","text":"<p>You can use alias for any sc-element by using <code>=</code> operator. There are some examples:</p> <pre><code>@file_alias = \"file://...\";;\n@link_alias = [];;\n@element_alias = element_idtf;;\n@edge_alias = (c -&gt; b);;\n@alias_to_alias = @other_alias;;\n</code></pre> <p>Warning</p> <p>Aliases visible just in a file scope.  You should define alias before usage.</p> <p>Note</p> <p>SCs-code is splitted into levels. Each level allows to minimize number of string symbols to represent the same structures.</p>"},{"location":"other/scs/#scs-level-1","title":"SCs level 1","text":"<p>SCs-code level 1 - is a simple representation of SC-code. It represents it with just simple triples. Each triple contains <code>subject</code>, <code>predicate</code>, <code>object</code> that are splitted by <code>|</code> symbol. Line <code>subject | predicate | object;;</code> is a sentence.</p> <p>Identifier of <code>subject</code>, <code>predicate</code>, <code>object</code> build with rule:</p> <pre><code>&lt;type&gt;#&lt;identifier&gt;\n</code></pre> <p>Where <code>type</code> - is an element type specification. It can be one of possible values:</p> <ul> <li><code>sc_node</code> - equal to ;</li> <li><code>sc_link</code> - equal to ;</li> <li><code>sc_edge_dcommon</code> - equal to ;</li> <li><code>sc_edge_ucommon</code> - equal to ;</li> <li><code>sc_edge_main</code> - equal to ;</li> <li><code>sc_edge_access</code> - equal to .</li> </ul> <p>Examples</p> SCg construction Equal SCs-level 1 text <pre>\n        <code>\n// append set of apples into fruit set\nsc_node#fruit | sc_edge_main#... | sc_node#apple;;\n// append set of bananas into fruit set\nsc_node#fruit | sc_edge_main#... | sc_node#banana;;\n        </code>\n      </pre> <pre>\n        <code>\nsc_node#apple | sc_edge_dcommon#..e | \"file://apple.png\";;\n/*append edge from nrel_image relation into\n  edge between apple set and it's image*/\nsc_node#nrel_image | sc_edge_main#... | sc_edge_dcommon#..e;;\n        </code>\n      </pre> <p>SCs-level 1 allows you to represent any kind of SC-code construction. It's a low-level representation and commonly used as a transport format, that is very simple for parsing.</p>"},{"location":"other/scs/#scs-level-2","title":"SCs level 2","text":"<p>This level of SCs-text add two new features:</p> <ul> <li>using of extended alphabet of edges;</li> <li>using of compound identifiers of an edges.</li> </ul> <p>On this level you can make sentences by rule: <pre><code>&lt;element&gt; &lt;edge&gt; &lt;element&gt;;;\n</code></pre></p> <p>Where <code>&lt;edge&gt;</code> can be on of values:</p> SCs SCg equivalent `&lt;` or `&gt;` `&lt;&gt;` `&lt;..` or `..&gt;` `&lt;=&gt;` `_&lt;=&gt;` `&lt;=` or `=&gt;` `_&lt;=` or `_=&gt;` `&lt;-` or `-&gt;` `_&lt;-` or `_-&gt;` `&lt;|-` or `-|&gt;` `_&lt;|-` or `_-|&gt;` `` `_` `&lt;~` or `~&gt;` `_&lt;~` or `_~&gt;` `&lt;|~` or `~|&gt;` `_&lt;|~` or `_~|&gt;` `` `_` SCg construction Equal SCs-level 2 text <pre>\n        <code>\nfruit -&gt; apple;;\n// backward direction\nbanana &lt;- fruit;;\n        </code>\n      </pre> <p>Compound identifier of an edge builds as a sentence in SCs-level 2, but without <code>;;</code> separator and inside brackets <code>()</code>: <code>(&lt;element&gt; &lt;edge&gt; &lt;element&gt;)</code>. So that allows to simplify usage of an edge as a source or target of another one.</p> <p>Examples</p> SCg construction Equal SCs-level 2 text <pre>\n        <code>\nnrel_image -&gt; (fruit =&gt; \"file://apple.png\");;\n        </code>\n      </pre> <pre>\n        <code>\nd -&gt; (c -&gt; (a -&gt; b));;\n        </code>\n      </pre> <pre>\n        <code>\n(a -&gt; b) -&gt; (c &lt;- d);;\n        </code>\n      </pre>"},{"location":"other/scs/#scs-level-3","title":"SCs level 3","text":"<p>This level of SCs-text allows to minimize symbols to represent constructions like this one: </p> <pre><code>c -&gt; (a -&gt; b);;\n</code></pre> <p>To do that you should use sentence like this:</p> <pre><code>&lt;object&gt; &lt;edge&gt; &lt;attribute&gt;: &lt;object&gt;\n</code></pre> <p>For this example it would be like this:</p> <pre><code>a -&gt; c: b;;\n</code></pre> <p>In case, when output edge from <code>c</code> is an variable, then use <code>::</code> splitter instead of <code>:</code>:</p> <pre><code>a -&gt; c:: b;;\n</code></pre> <p>equal to:</p> <pre><code>c _-&gt; (a -&gt; b);;\n</code></pre> Note: you can use <code>:</code>, <code>::</code> just to replace <code>-&gt;</code> or <code>_-&gt;</code> edges.  <p>Examples</p> SCg construction Equal SCs-level 3 text <pre>\n        <code>\napple =&gt; nrel_image: \"file://apple.png\";;\n        </code>\n      </pre> Note: it is possible to use any number of <code>:</code>, <code>::</code> in one sentence.        <pre>\n        <code>\na -&gt; c: d:: b;;\n        </code>\n      </pre>"},{"location":"other/scs/#scs-level-4","title":"SCs level 4","text":"<p>This level of SCs-text allows to combine many setences with one element into one. For that pupropses used ';' symbol. So if we have some sentences like:</p> <pre><code>x -&gt; y;;\nx &lt;- z;;\nx =&gt; h: r;;\n</code></pre> <p>Then using SCs level 4 we can write them like this:</p> <pre><code>x -&gt; y;\n  &lt;- z;\n  =&gt; h: r;;\n</code></pre> <p>Another words, this level of SCs text, allows to use source element one time.</p> <p>Examples</p> SCg construction Equal SCs-level 4 text <pre>\n        <code>\nfruit -&gt; apple;\n      -&gt; banana;;\n        </code>\n      </pre> <pre>\n        <code>\na -&gt; c: d: b;\n  -&gt; e;\n  -&gt; g: f;;\n        </code>\n      </pre>   ### SCs level 5  Internal sentences added to `SCs-text` on this level. They are wrapped by `(* ... *)` brackets. This type of sentences allow to describe connections of an element inplace. You can place these internal sentences after `object` element in triple (`subject -&gt; object (* ... *);;`), but before `;;` separator. You can use level `2-4` sentences inside this one. But there is a just one rule:   !!! note \"\"     You doesn't need to specify start element for each sentece. Because object (for which internal sentece builds) is going to be a subject for all internal sentences   Look at the examples, to understand how it works:    SCs-level 2-4 SCs-level 5 Description <pre><code>\nset -&gt; attr: item;;\nitem -&gt; subitem;;\n        </code></pre> <pre><code>\nset\n  -&gt; attr: item \n    (*\n      -&gt; subitem;;\n    *);;\n      </code></pre>      This is a simple example, that allow to make an <code>SCs-text</code> more readable and useful. In this case text has a sublevels, that allow      to read it faster.      <pre>\n        <code>\nset -&gt; attr: item;;\nitem -&gt; subitem;;\nitem -&gt; attr2: subitem2;;\n        </code>\n      </pre> <pre>\n        <code>\nset \n  -&gt; attr: item\n  (* \n    -&gt; subitem;;\n    -&gt; attr2:\n      subitem2;;\n  *);;\n        </code>\n      </pre>      You can use as more as you need sentences in <code>(* *)</code>, but all of them should be separated by <code>;;</code>.      <pre><code>\n@en_idtf = [sc-element];;\n@ru_idtf = [sc-\u044d\u043b\u0435\u043c\u0435\u043d\u0442];;\n@en_idtf &lt;- lang_en;;\n@ru_idtf &lt;- lang_ru;;\nsc_element \n  =&gt; nrel_main_idtf: \n    @en_idtf;\n    @ru_idtf;;\n      </code></pre> <pre><code>\nsc_element\n  =&gt; nrel_main_idtf:\n    [sc-element]\n    (* &lt;- lang_en;; *);\n  =&gt; nrel_main_idtf:\n    [sc-\u044d\u043b\u0435\u043c\u0435\u043d\u0442]\n    (* &lt;- lang_ru;; *);;\n        </code></pre>      This type of syntax is very useful, when you need to specify some meta information on <code>sc-link</code>'s.     In this example we specify two main identifiers for a <code>sc_element</code>. One is an english (<code>lang_en</code>) identifier,     another one is a russian (<code>lang_ru</code>).        ### SCs level 6  There are some new complex aliases, that adds by this level of `SCs-text`:  * `[...]` - this is a short representation of `sc-link` with a content. You can create `sc-link` with a specified content by using this feature. There are all possible cases:  Type Description Example `string` You can write any string that you wish inside <code>[ ... ]</code> alias <pre><code>\nx -&gt; [any string];;\nx -&gt; [this is a \n multiline text];;\n        </code></pre> `number` You can specify a number as a binary data. To do that, just use syntax:         <code>[^\"type: value\"]</code>. Where <code>type</code> is a one of possible types:         <ul> <li><code>int</code> - signed integer value (32 bit). You can also use such types for an integer:             <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> </li> <li><code>uint</code> - unsigned integer value (32 bit). You can also use such type for an unsigned integer:             <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code> </li> <li><code>float</code> - 32-bit float value</li> <li><code>double</code> - 64-bit float value</li> </ul> <pre><code>\nx -&gt; [^\"float: 435.2346\"];;\nx -&gt; [^\"int8: 7\"];;\nx -&gt; [^\"uint: 781236\"];;\n        </code></pre>   * `[* ... *]` this is a short representation of <code>sc-structure</code>. You can use just <code>SCs-text</code> inside this brackets.   So these brackets will designate an <code>sc-structure</code> (<code>sc-node</code> with a type <code>sc_node_struct</code>). All elements inside   brackets will have ingoing edge (type <code>sc_edge_main</code>) from that <code>sc-node</code>.    SCs-text level 2-5 SCs-text level 6 <pre><code>\n@edge_alias = (set -&gt; item);;\nstruct -&gt; set; item; @edge_alias;;\n        </code></pre> <pre><code>\n@struct = [ set -&gt; item;; ];;\n        </code></pre>   !!! important \"Thats important\"     `SCs-text` inside `[* ... *]` has the same rules and semantic, like it was be in a separated file  * `{ ... }` this is a short representation of set. This feature allow to make sets in very fast way.   Syntax looks like:    <pre><code>@set = {\n  element1;\n  attr2: element2;\n  ...\n  last_element // no semicolon after last element\n}\n</code></pre> SCs-text level 2-5 SCs-text level 6 Comments <pre><code>\nset\n  &lt;- sc_node_tuple;\n  -&gt; element1;\n  -&gt; attr2: element2;\n  -&gt; element3;;\n      </code></pre> <pre><code>\n@set = {\n  element1;\n  attr2: element2;\n  element3 // no semicolon\n};;\n      </code></pre> Using set looks much cleaner. You can use even attributes on it <pre><code>\nmeta_set \n  &lt;- sc_node_tuple;\n  -&gt; set1;\n  -&gt; set2;;\n\nset1\n  &lt;- sc_node_tuple;\n  -&gt; element1;\n  -&gt; attr2: element2;\n  -&gt; element3;;\n\nset2\n  &lt;- sc_node_tuple;\n  -&gt; element5;\n  -&gt; element6;;\n\nset3\n  &lt;- sc_node_tuple;\n  -&gt; element10;;\n\nelement \n  =&gt; nrel_relation:\n    set3;;\n      </code></pre> <pre><code>\n@meta_set = {\n  {\n    element1;\n    attr2: element2;\n    element3\n  };\n  {\n    element5;\n    element6\n  }\n};;\n\nelement \n  =&gt; nrel_relation:\n  {\n    element10\n  };;\n      </code></pre> You can use set alias inside any other complex aliases and triples.    ### Keynodes  There are a list of element type keynodes, that can be used to specify type of an element:  | Keynode                           | Equal sc-type                       | Equal SCg-element | --------------------------------- | ----------------------------------- | -------------- | sc_node                           | ScType::Node                        | ![SCg-edge](../images/scg/scg_node.png) | sc_link                           | ScType::Link                        | ![SCg-edge](../images/scg/scg_link.png) | sc_edge_dcommon                   | ScType::EdgeDCommon                 | ![SCg-edge](../images/scg/scg_edge_common_orient.png) | sc_edge_ucommon                   | ScType::EdgeUCommon                 | ![SCg-edge](../images/scg/scg_edge_common.png) | sc_edge_main                      | ScType::EdgeAccessConstPosPerm      | ![SCg-edge](../images/scg/scg_edge_const_pos_perm.png) | sc_edge_access                    | ScType::EdgeAccess                  | ![SCg-edge](../images/scg/scg_edge_access.png) | sc_node_tuple                     | ScType::NodeTuple                   | ![SCg-edge](../images/scg/scg_node_const_tuple.png) ![SCg-edge](../images/scg/scg_node_var_tuple.png) | sc_node_struct                    | ScType::NodeStruct                  | ![SCg-edge](../images/scg/scg_node_const_struct.png) ![SCg-edge](../images/scg/scg_node_var_struct.png) | sc_node_role_relation             | ScType::NodeRole                    | ![SCg-edge](../images/scg/scg_node_const_role.png) ![SCg-edge](../images/scg/scg_node_var_role.png) | sc_node_norole_relation           | ScType::NodeNoRole                  | ![SCg-edge](../images/scg/scg_node_const_norole.png) ![SCg-edge](../images/scg/scg_node_var_norole.png) | sc_node_class                     | ScType::NodeClass                   | ![SCg-edge](../images/scg/scg_node_const_class.png) ![SCg-edge](../images/scg/scg_node_var_class.png) | sc_node_abstract                  | ScType::NodeAbstract                | ![SCg-edge](../images/scg/scg_node_const_abstract.png) ![SCg-edge](../images/scg/scg_node_var_abstract.png) | sc_node_material                  | ScType::NodeMaterial                | ![SCg-edge](../images/scg/scg_node_const_material.png) ![SCg-edge](../images/scg/scg_node_var_material.png)  There are old keynodes, that used for backward compatibility:  | Keynode                   | Equal sc-type | New keynode | | ------------------------- | ------------- | ----------- | | sc_arc_main               | ScType::EdgeAccessConstPosPerm | sc_edge_main | | sc_edge                   | ScType::EdgeUCommon | sc_edge_ucommon | | sc_arc_common             | ScType::EdgeDCommon | sc_edge_dcommon | | sc_arc_access             | ScType::EdgeAccess  | sc_edge_access | | sc_node_not_relation      | ScType::NodeClass | sc_node_class | | sc_node_not_binary_tuple  | ScType::NodeTuple | sc_node_tuple |  There is an example of usage:   SCs-code Equal SCg-code <pre>\na &lt;- sc_node_class;;\na _-&gt; _b;;\n_b &lt;- sc_node_material;;\n      </pre> <pre>\n_x =&gt; nrel_y: t;;\nnrel_y &lt;- sc_node_norole_relation;;\n      </pre>"},{"location":"sc-kpm/kpm/","title":"Agents","text":"<p>Knowledge processing machine (KPM) - is a set of modules. Each module contains implementation of sc-agents. Also they can contains any other functions and classes, than used by sc-agents implementation.</p>"},{"location":"sc-kpm/kpm/#scmodule","title":"ScModule","text":"<p>Module - is a dynamic library. That implement specified module class. To create module you need to do next steps:</p> <ol> <li>Create directory for your module in sc-kpm. For example: <code>sc-kpm/nl</code>;</li> <li>Go to created directory;</li> <li>Create file <code>CMakeLists.txt</code> with content (replace nl (module name) to yours one:</li> </ol> <p>CMakeLists.txt <pre><code>set(SC_IOT_SRC ${CMAKE_CURRENT_LIST_DIR})\nset(SOURCES\n    \"nl.cpp\"\n)\nset(HEADERS\n    \"nl.hpp\"\n)\ninclude_directories(${SC_IOT_SRC} ${SC_MEMORY_SRC})\nadd_library (nl SHARED ${SOURCES} ${HEADERS})\nadd_dependencies(nl sc-memory-cpp)\ntarget_link_libraries(nl sc-memory-cpp)\nsc_codegen(nl ${SC_IOT_SRC})\n</code></pre></p> <p>After that you need to create two files (cpp, hpp):</p> <p>nl.hpp</p> <pre><code>#pragma once\n#include &lt;sc-memory/cpp/sc_module.hpp&gt;\n#include \"nl.generated.hpp\"\nclass nlModule : public ScModule\n{\nSC_CLASS(LoadOrder(11))\nSC_GENERATED_BODY()\nvirtual sc_result InitializeImpl() override;\nvirtual sc_result ShutdownImpl() override;\n};\n</code></pre> <p>nl.cpp</p> <pre><code>#include \"nl.hpp\"\nSC_IMPLEMENT_MODULE(nlModule)\nsc_result nlModule::InitializeImpl()\n{\nreturn SC_RESULT_OK;\n}\nsc_result nlModule::ShutdownImpl()\n{\nreturn SC_RESULT_OK;\n}\n</code></pre>"},{"location":"sc-kpm/kpm/#scagent","title":"ScAgent","text":"<p>To create sc-agent implementation you need:</p> <ol> <li>create source and header file for sc-agent implementation</li> <li>add created files into <code>CMakeLists.txt</code></li> </ol> <p>CMakeLists.txt <pre><code>...\n\nset(SOURCES\n  \"nl.cpp\"\n\"nlApiAi.cpp\"\n)\nset(HEADERS\n  \"nl.hpp\"\n\"nlApiAi.hpp\"\n)\n...\n</code></pre></p> <p>nlApiAi.hpp <pre><code>#pragma once\n#include \"wrap/kpm/sc_agent.hpp\"\n#include \"nlApiAi.generated.hpp\"\nnamespace nl\n{\nclass AApiAiParseUserTextAgent : public ScAgentAction\n{\nSC_CLASS(Agent, CmdClass(\"command_process_user_text_message\"))\nSC_GENERATED_BODY()\n};\n}\n</code></pre></p> <p>nlApiAi.cpp <pre><code>#include \"nlApiAi.hpp\"\nnamespace nl\n{\nSC_AGENT_ACTION_IMPLEMENTATION(AApiAiParseUserTextAgent)\n{\n// implement agent logic there\nreturn SC_RESULT_ERROR;\n}\n}\n</code></pre></p> <p>SC_AGENT_ACTION_IMPLEMENTATION - is a macros that insert generated code an minimize work. You just insert this one (with class name as parameter), and implement it like a function. During implementation you can use such variables: * <code>requestAddr</code> - <code>ScAddr</code> of command (action) instance that was initiated; * <code>resultAddr</code> - <code>ScAddr</code> of sc-structure that designate command (action) result; * <code>mMemoryCtx</code> - memory context that can be used to work with <code>ScMemory</code>.</p> <p>If sc-agent finished work without any errors, then it must return <code>SC_RESULT_OK</code>, otherwise - one of code error <code>SC_RESULT_ERROR_...</code>. Result of agent will be automaticaly added into specified set:</p> <p></p> <p>Possible result sets:</p> <ul> <li><code>sc_result_error</code> - unknown error;</li> <li><code>sc_result_ok</code> - no any errors (successfull finish);</li> <li><code>sc_result_error_invalid_params</code> - invalid parameters of agent;</li> <li><code>sc_result_error_invalid_type</code> - invalid type error (invalid type of data of something else);</li> <li><code>sc_result_error_io</code> - input/output error (can't read/write something from/to any source);</li> <li><code>sc_result_invalid_state</code> - invalid state of processing data;</li> <li><code>sc_result_error_not_found</code> - something wasn't found (for example: can't resolve element by identifier);</li> <li><code>sc_result_error_no_write_rights</code> - agent hasn't rights to write something;</li> <li><code>sc_result_error_no_read_rights</code> - agent hans't rights to read something.</li> </ul> <p>It's important:</p> <ul> <li>All sc-agents class names must to be started with A symbol;</li> <li>You can implement more than one <code>ScAgent</code> class in on source/header file;</li> <li>Don't use any other memory contexts instead of <code>mMemoryCtx</code> in <code>ScAgent</code> implementation;</li> <li>You need always include <code>&lt;you_header&gt;.generated.hpp</code> file into your header, if you have any metadata. This include must be a last one in a file.</li> </ul>"},{"location":"sc-kpm/kpm/#scevent","title":"ScEvent","text":"<p>This type of objects allows you to subscribe to any events in <code>ScMemory</code>. There are c++ classes that correspond to specified event types:</p> <ul> <li><code>ScEventAddOutputEdge</code> - emits each time, when output (outgoing) edge (from specified element) added;</li> <li><code>ScEventAddInputEdge</code> - emits each time, when input (ingoing) edge (into specified element) added;</li> <li><code>ScEventRemoveOutputEdge</code> - emits each time, when output (outgoing) edge (from specified element) removed;</li> <li><code>ScEventRemoveInputEdge</code> - emits each time, when input (ingoing) edge (into specified element) removed;</li> <li><code>ScEventEraseElement</code> - emits, when specified element removed;</li> <li><code>ScEventContentChanged</code> - emits each time, when content of specified sc-link changed.</li> </ul> <p>Each event constructor takes 3 parameters:</p> <ul> <li><code>ctx</code> - <code>ScMemoryContext</code> that will be used to work with event;</li> <li><code>addr</code> - <code>ScAddr</code> of element that need to be listen for a specified event;</li> <li><code>func</code> - delegate to a callback function, that will be called on each event emit (<code>bool func(ScAddr const &amp; listenAddr, ScAddr const &amp; edgeAddr, ScAddr const &amp; otherAddr)</code>). Description of parameters for this function you can see in table below (for each event type). Note: callback function will be called in another thread!</li> </ul> <p>Table of description (parameters of callback function named on pictures, if there are no parameter name on picture, then it's would have an empty value):</p> Class Description ScEventAddOutputEdge        Callback calls each time, when any type edge <code>edgeAddr</code> between <code>listenAddr</code> and <code>otherAddr</code> create.        Example C++ code:       <pre><code>\nauto const callback [](ScAddr const &amp; listenAddr,\n                       ScAddr const &amp; edgeAddr,\n                       ScAddr const &amp; otherAddr)\n{\n    // listenAddr - ScAddr of source element\n    //  (listen it in event)\n    // edgeAddr - ScAddr of added output edge\n    // otherAddr - target element of added edge\n    ...\n    return true; // if failed, then return false\n};\nScEventAddOutputEdge evt(ctx, addr, callback);\n      </code><pre>\n    ScEventAddInputEdge\n    \n      Callback calls each time, when any type edge <code>edgeAddr</code> between <code>otherAddr</code> and <code>listenAddr</code> create.\n      \n      Example C++ code:\n      <pre><code>\nauto const callback [](ScAddr const &amp; listenAddr,\n                       ScAddr const &amp; edgeAddr,\n                       ScAddr const &amp; otherAddr)\n{\n    // listenAddr - ScAddr of target element\n    //  (listen it in event)\n    // edgeAddr - ScAddr of added input edge\n    // otherAddr - source element of added edge\n    ...\n    return true; // if failed, then return false\n};\nScEventAddInputEdge evt(ctx, addr, callback);\n      </code></pre>\n    ScEventRemoveOutputEdge\n    \n      Callback calls each time, when any type edge <code>edgeAddr</code> between <code>listenAddr</code> and any element <code>otherAddr</code> erase.\n      \n      Example C++ code:\n      <pre><code>\nauto const callback [](ScAddr const &amp; listenAddr,\n                       ScAddr const &amp; edgeAddr,\n                       ScAddr const &amp; otherAddr)\n{\n    // listenAddr - ScAddr of source element\n    //  (listen it in event)\n    // edgeAddr - ScAddr of erased output edge\n    // otherAddr - target element of erased edge\n    ...\n    return true; // if failed, then return false\n};\nScEventRemoveOutputEdge evt(ctx, addr, callback);\n      </code></pre>\n    ScEventRemoveInputEdge\n    \n      Callback calls each time, when any type edge <code>edgeAddr</code> between any element <code>otherAddr</code> and <code>listenAddr</code> erase.\n      \n      Example C++ code:\n      <pre><code>\nauto const callback [](ScAddr const &amp; listenAddr,\n                       ScAddr const &amp; edgeAddr,\n                       ScAddr const &amp; otherAddr)\n{\n    // listenAddr - ScAddr of target element\n    //  (listen it in event)\n    // edgeAddr - ScAddr of erased input edge\n    // otherAddr - source element of erased edge\n    ...\n    return true; // if failed, then return false\n};\nScEventRemoveOutputEdge evt(ctx, addr, callback);\n      </code></pre>\n    ScEventEraseElement\n    \n    Callback calls when <code>listenAddr</code> erased.\n    \n    Example C++ code:\n    <pre><code>\nauto const callback [](ScAddr const &amp; listenAddr,\n                       ScAddr const &amp; edgeAddr,\n                       ScAddr const &amp; otherAddr)\n{\n  // listenAddr - ScAddr of erased element\n  //  (listen it in event)\n  // edgeAddr - empty\n  // otherAddr - empty\n  ...\n  return true; // if failed, then return false\n};\nScEventEraseElement evt(ctx, addr, callback);\n    </code></pre>\n    ScEventContentChanged\n    \n      Callback calls when content of <code>listenAddr</code> changed.\n      \n      Example C++ code:\n      <pre><code>\nauto const callback [](ScAddr const &amp; listenAddr,\n                       ScAddr const &amp; edgeAddr,\n                       ScAddr const &amp; otherAddr)\n{\n  // listenAddr - ScAddr of element that has\n  //     content changed (listen it in event)\n  // edgeAddr - empty\n  // otherAddr - empty\n  ...\n  return true; // if failed, then return false\n};\nScEventContentChanged evt(ctx, addr, callback);\n      </code></pre>"},{"location":"sc-kpm/kpm/#scwait","title":"ScWait","text":"<p>This type of objects used to wait until some event emits. It usually used, when on of an <code>ScAgent</code> want to wait result of another one. There are next kind of <code>ScWait</code> objects:</p>\n<ul>\n<li><code>ScWait</code>- lock run flow until simple event emits. You can see the list of this events in the Class propertires table (Event property);</li>\n<li><code>ScWaitCondition</code> - lock run flow until simple event emits and specified conditional check returns true. Another words, this works like an <code>ScWait</code>, but returns to run flow if special condition function returns true. Condition function receive 3 parameters (see ScEvent for more details about them);</li>\n<li><code>ScWaitConstruction</code> - wait object, that wait until specified construction would be appeared in a memory. (Not implemented yet)</li>\n</ul>\n<p>There are some examples of usage for specified <code>ScWait</code> objects:</p>\n<p>Wait input edge into addr\n<pre><code>ScWait&lt;ScEventAddInputEdge&gt; waiter(ctx, addr);\nwaiter.Wait();\n</code></pre></p>\n<p>Wait input edge into addr, with condition\n<pre><code>auto check = [](ScAddr const &amp; listenAddr,\nScAddr const &amp; edgeAddr,\nScAddr const &amp; otherAddr)\n{\n... // check condition there\nreturn false; // return true or false depending on condition\n};\nScWaitCondition&lt;ScEventAddInputEdge&gt; waiter(ctx, addr, SC_WAIT_CHECK(check));\nwaiter.Wait();\n</code></pre></p>\n<p>There are some preimplemented most common waiters:\n* <code>ScWaitActionFinished</code> - wait until specified <code>command</code> will be finished. Example:\n<pre><code>...\nScWaitActionFinished waiter(ctx, commandAddr);\nwaiter.Wait();\n...\n</code></pre></p>"},{"location":"sc-search/templates/","title":"Template","text":"<p>Templates is a very powerful mechanism to work with semantic network (graph). You can search and generate any constructions using templates. There are list of available classes to work with templates: * <code>ScTemplate</code> - class that represents template in C++ code; * <code>ScTemplateParams</code> - parameters that contains values of variables in template. This class usually used when you generate construction by template; * <code>ScTemplateSearchResult</code> - contains result of search by template (list of found constructions); * <code>ScTemplateSearchResultItem</code> - represents on search result item; * <code>ScTemplateGenResult</code> - represent result of generation by template.</p>"},{"location":"sc-search/templates/#sctemplate","title":"ScTemplate","text":"<p>Class to work with templates in c++. Before reading this paragraph you need to read common information about types.</p> <p>Let use <code>f</code> symbols for constant parameter of template. Let use <code>a</code> symbol for a variable parameter of template. Then template to search all output edges from specified sc-element will be a triple: * where first element is known <code>f</code>; * second and third elements need to be found <code>a</code>.</p> <p>There are possible 3 types of simple templates: * <code>f_a_a</code> - template to find all outgoing edges from a specified sc-element; * <code>f_a_f</code> - template to find all edges between two specified sc-elements; * <code>a_a_f</code> - template to find all ingoing edges to a specified sc-element.</p> <p>There are some methods available for <code>ScTemplate</code> class: * <code>triple</code> - method that adds triple construction into template. There are some examples of using this function to produce simple templates:</p> Template Description f_a_a Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Triple(\n  param1,\n  ScType::EDGE_ACCESS_VAR_POS_PERM,\n  ScType::NODE_VAR\n);\n</code></pre> This triple template using to traverse output edges from specified sc-element.       There <code>param1</code> is a known <code>ScAddr</code> of sc-element. It must be a valid (use <code>ScAddr::IsValid</code> method to check). Where <code>_param2</code> and <code>_param3</code> are <code>ScType</code> for compare by search engine. When search engine will traverse output edges from <code>param1</code>. Construction will be added into traverse result, where output edge from <code>param1</code>, will suitable to specified type <code>_param2</code>, and type of target element of this edge will be sutable for a type <code>_param3</code>.       You can use any type of <code>_param3</code> (including edges) depending on construction you want to find. But <code>_param2</code> should be any type of variable edge.      f_a_f Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Triple(\n  param1,\n  ScType::EDGE_ACCESS_VAR_POS_PERM,\n  param3\n);\n</code></pre> This triple template using to find edge between <code>param1</code> and <code>param3</code>.     There are <code>param1</code> and <code>param3</code> a known <code>ScAddr</code> of sc-elements. Edge type <code>_param2</code> should be variable.       a_a_f Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Triple(\n  ScType::NODE_VAR,\n  ScType::EDGE_ACCESS_VAR_POS_PERM,\n  param3\n);\n</code></pre> This triple template using to traverse input edges from specified sc-element.     There <code>param3</code> is a known <code>ScAddr</code> of sc-element. You can use any type of <code>_param1</code> (including edges) depending on construction you want to find. But <code>_param2</code> should be any type of variable edge.      <p>When template search engine works, it tries to traverse graph by simple (triple) template in order they specified. For example we need to check if specified sc-element (<code>_device</code>) is included into <code>device</code> set and <code>device_enabled</code> set:</p> <p></p> <p>Code that generates equal template <pre><code>ScAddr device_addr, device_enabled_addr;\n...\nScTemplate templ;\ntempl.Triple(\ndevice_addr,    // sc-addr of device node\nScType::EDGE_ACCESS_VAR_POS_PERM,\nScType::NODE_VAR &gt;&gt; \"_device_instance\"\n);\ntempl.Triple(\ndevice_enabled_addr,    // sc-addr of device_enabled node\nScType::EDGE_ACCESS_VAR_POS_PERM,\n\"_device_instance\"\n);\n</code></pre> In code you can see a construction <code>ScType::NODE_VAR &gt;&gt; \"_device_instance\"</code> - this is a naming for a template element. It allows to set name for a specified sc-element in template, and use it many times in different triples. You can see, that in the second triple we use this name <code>\"_device_instance\"</code>. That means, that we need to place search result from a first triple into the second. So the second triple is a <code>f_a_f</code> style triple.</p> <p>So if you want to use the same element <code>_x</code> in different triples, and you doesn't know it <code>ScAddr</code>, then just use two main rules: * set name of this element in a first occurrence of this element in template triples. You need to use <code>&gt;&gt;</code> operator to do this (see code below, last element of first triple); * when you need to use named element in next triples, then just use it name instread of <code>ScType</code> or <code>ScAddr</code> (see code below, first element if second triple).</p> <p>Example code with naming</p> <pre><code>ScTemplateTempl;\ntempl.Triple(\nany_addr, // sc-addr of known sc-element\nScType::EDGE_ACCESS_VAR_POS_PERM,  // type of unknown edge\nScType::NODE_VAR &gt;&gt; \"_x\"  // type and name for an unknown sc-element\n);\ntempl.Triple(\n\"_x\",  // say that is the same element as the last on in a previous triple\nScType::EDGE_ACCESS_VAR_POS_PERM,  // type of unknown edge\nScType::NODE_VAR  // type of unknown sc-element\n);\n</code></pre> <p>Also you can generate templates using SCs-code. Example code:</p> <pre><code>ScTemplate templ; char const * data = \"_device_instance\"\n\"  _&lt;- device;\"\n\"  _&lt;- device_enabled;;\";\nctx.HelperBuildTemplate(templ, data);\n</code></pre> <p>During template building all constants will be resolved by their system identifier (in example: <code>device</code>, <code>device_enabled</code>), so in result <code>templ</code> will be contain template:</p> <p></p>"},{"location":"sc-search/templates/#search","title":"Search","text":"<p>Search algorithm trying to find all possible variants of specified construction. It use any constants (available <code>ScAddr</code>'s from parameters to find equal constructions in sc-memory).</p>"},{"location":"sc-search/templates/#search-in-construction","title":"Search in construction","text":"<p>Do the same as Search, but check if all elements of found constructions are in a specified set.</p> <p>Example:</p> <pre><code>ScTemplate templ; templ.Triple(\nanyAddr &gt;&gt; \"_anyAddr\",\nScType::EdgeAccessVarPosPerm &gt;&gt; \"_edge\",\nScType::NodeVar &gt;&gt; \"_trgAddr\");\nctx.HelperSearchTemplateInStruct(templ, anyStructAddr, result)\n</code></pre>"},{"location":"sc-search/templates/#generate","title":"Generate","text":""},{"location":"sc-tools/kb_builder/","title":"Builder","text":"<p>Builder tool allow to build knowledge base from a sources. You can find it in a <code>bin</code> directory. There are options of this tool:</p> <pre>\nsc-builder --help\n\nBuilder usage:\n  --help                      Display this message\n  --version                   Displays version number\n  -i [ --input-path ] arg     Path to directory with sources\n  -o [ --output-path ] arg    Path to output directory (repository)\n  -c [ --clear-output ]       Clear output directory (repository) before build\n  -s [ --settings ] arg       Path to configuration file for sc-memory\n  -f [ --auto-formats ]       Enable automatic formats info generation\n</pre> <p>Example of usage:</p> <pre><code>./bin/sc-builder -i ./kb -o ./kb.bin -c -s ./bin/config.ini -f -e ./bin/extension\n</code></pre>"},{"location":"sc-tools/kb_builder/#extensions","title":"Extensions","text":"<p>There is a possibility to specify which extensions will be runned during a knowledge base building. You can specify that with parameter <code>--enabled-ext</code>. Value of this parameter is a path to file that contains list of allowed extensions. Example of file content:</p> <pre><code>sc-utils\n</code></pre> <p>In that case just <code>sc-utils</code> extensions will be loaded during knowledge base build process.</p> <p>Example of usage:</p> <pre><code>./bin/sc-builder -i ./kb -o ./kb.bin -c -s ./bin/config.ini -f -e ./bin/extension --enabled-ext ./config/build_ext.list\n</code></pre>"},{"location":"storage/sc-dictionary/","title":"Sc-dictionary-based file storage","text":"<p>Sc-elements identification, string literals and images storing, as well as their processing takes place in  a file storage module. A file storage is a software functional module that uses a sc-dictionary  that stores and processes pairs of the form .  <p>A sc-dictionary itself is universal and is able to store objects and arrays of objects of any type by key in the  form of a string. The dictionary structure is programmatically a prefix tree, where intermediate nodes are common  substrings for strings stored in the tree, and terminal nodes are containers for storing data by value of strings added to  a dictionary tree.</p> <p>A sc-dictionary implementation based on the prefix tree allows:</p> <ul> <li>to represent data in a hierarchical fashion;</li> <li>to place and receive data for sublinear time from the length of the string (key);</li> <li>to store common leading substrings of multiple strings in one place in the shared memory dedicated to the tree;</li> <li>to reduce memory size for storing strings in multiple languages. Techniques such as alphabet reduction can alleviate  high space complexity by reinterpreting the original string as a long string in a smaller alphabet;</li> </ul>"},{"location":"storage/sc-dictionary/#sc-dictionary-implementation","title":"Sc-dictionary implementation","text":"<p>A file storage and sc-dictionary are implemented by \u0421 language means. Together with the implementation of  the file storage and dictionary, support for the  C dictionary API is provided.</p> <p>Common API methods of sc-dictionary implementation and their description are represented in the next table:</p> C API method Specification sc_bool sc_dictionary_initialize(sc_dictionary ** dictionary, sc_uint8 children_size,         void (*char_to_int)(sc_char, sc_uint8 *, const sc_uint8 *)) It initializes sc-dictionary tree structure with standard memory configuration. If a pointer to sc-dictionary had          been not null_ptr at the time of memory setup, then the method returns SC_FALSE. sc_bool sc_dictionary_destroy(sc_dictionary * dictionary, sc_bool (*node_destroy)(sc_dictionary_node *, void **)) It destroys sc-dictionary tree structure, freeing memory for all nodes ib tree. If a pointer to sc-dictionary had          been null_ptr at the time of memory freeing, then the method returns SC_FALSE. sc_dictionary_node * sc_dictionary_append(sc_dictionary * dictionary, sc_char * string, sc_uint32 string_size, void * value) It places data by key string. Moreover, if earlier in the tree there was a string that has a common          prefix with to append, then the rest of the original string is appended to the tree node at which this prefix ends.         If other data stored by the original string, then it will be replaced by new one. The method return terminal node,         in which has been stored data by key string. sc_bool sc_dictionary_has(sc_dictionary * dictionary, const sc_char * string, sc_uint32 string_size) It checks for key existence in sc-dictionary. If sc-dictionary has not such key string,          then method returns SC_FALSE. void * sc_dictionary_get_by_key(sc_dictionary * dictionary, const sc_char * string, sc_uint32 string_size) It gets data by key string. If sc-dictionary has not such key string,          then method returns null_ptr. sc_bool sc_dictionary_get_by_prefix(sc_dictionary * dictionary, const sc_char * string, sc_uint32 string_size,          sc_bool (*callable)(sc_dictionary_node *, void **), void ** dest)) It visits data by key string prefix. It returns SC_FALSE if `callable` function returned SC_FALSE. void sc_dictionary_visit_down_nodes(sc_dictionary * dictionary, void (*callable)(sc_dictionary_node *, void **), void ** dest) It visits up down all nodes and call specified routine for them. A result of procedure completion saves into `dest`. void sc_dictionary_visit_up_nodes(sc_dictionary * dictionary, void (*callable)(sc_dictionary_node *, void **), void ** dest) It visits down up all nodes and call specified routine for them. A result of procedure completion saves into `dest`. <p>A sc-dictionary implementation uses sc-list structure to store arrays of data. A sc-container-iterator is used to iterate on sc-list elements.</p>"},{"location":"storage/sc-dictionary/#usage-example","title":"Usage example","text":"<pre><code>extern \"C\"\n{\n#include \"sc-container/sc-dictionary/sc_dictionary.h\"\n#include \"sc-container/sc-list/sc_list.h\" }\nsc_uint8 _sc_uchar_dictionary_children_size()\n{\nsc_uint8 const max_sc_char = 255;\nsc_uint8 const min_sc_char = 1;\nreturn max_sc_char - min_sc_char + 1;\n}\nvoid _sc_uchar_dictionary_sc_char_to_sc_int(sc_char ch, sc_uint8 * ch_num, sc_uint8 const * mask)\n{\n*ch_num = 128 + (sc_uint8)ch;\n}\nsc_bool _sc_uchar_dictionary_initialize(sc_dictionary ** dictionary)\n{\nreturn sc_dictionary_initialize(\ndictionary, _sc_uchar_dictionary_children_size(), _sc_uchar_dictionary_sc_char_to_sc_int);\n}\nint main()\n{\nsc_dictionary * dictionary;\n_sc_uchar_dictionary_initialize(&amp;dictionary);\nsc_char string[] = \"sc-dictionary\";\nsc_uint32 const string_size = strlen(string);\nsc_uint8 value = 10;\nsc_dictionary_append(dictionary, string, string_size, (void *)value);\nsc_uint8 const found_value = (sc_uint8)sc_dictionary_get_by_key(dictionary, string, string_size);\nsc_dictionary_destroy(&amp;dictionary, sc_dictionary_node_destroy);\nreturn 0;\n}\n</code></pre>"}]}